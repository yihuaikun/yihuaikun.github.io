<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SpringCloud | 向java工程师迈进</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://yihuaikun.github.io/favicon.ico?v=1576155153772">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://yihuaikun.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yihuaikun.github.io">
  <img class="avatar" src="https://yihuaikun.github.io/images/avatar.png?v=1576155153772" alt="">
  </a>
  <h1 class="site-title">
    向java工程师迈进
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              SpringCloud
            </h2>
            <div class="post-info">
              <span>
                2019-12-12
              </span>
              <span>
                29 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="springcloud之netflix">springcloud之Netflix</h1>
<h2 id="netflix体系简介">Netflix体系简介</h2>
<p>Netflix这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了</p>
<h3 id="核心成员">核心成员</h3>
<h4 id="netflix-eureka">Netflix Eureka</h4>
<p>服务中心，云端服务发现，一个基于  REST  的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。</p>
<h4 id="netflix-ribbon">Netflix Ribbon</h4>
<p>Ribbon是一个客户端负载均衡组件，帮我们实现后端服务节点动态扩容，而不影响调用方。</p>
<h4 id="netflix-hystrix">Netflix Hystrix</h4>
<p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。</p>
<h4 id="netflix-zuul">Netflix Zuul</h4>
<p>Zuul  是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web  网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。</p>
<h4 id="netflix-archaius">Netflix Archaius</h4>
<p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置，   原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p>
<h1 id="eureka和ribbon">Eureka和Ribbon</h1>
<h3 id="单机模式的eureka和ribbon">单机模式的Eureka和Ribbon</h3>
<h4 id="前置工作">前置工作</h4>
<h5 id="1首先是依赖的搭配使用">1.首先是依赖的搭配使用</h5>
<p>详细介绍参见<a href="https://spring.io/projects/spring-cloud">Springcloud依赖版本搭配配置参见</a></p>
<h5 id="2然后再公用模块加依赖">2.然后再公用模块加依赖</h5>
<pre><code class="language-xml">  &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;springboot.version&gt;2.1.6.RELEASE&lt;/springboot.version&gt;
        &lt;springcloud.version&gt;Greenwich.SR2&lt;/springcloud.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.10&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                &lt;!-- 注意：SpringCloud最新的Greenwich版本是基于SpringBoot2.1.x(Greenwich)版本构建的
                    所以这里不支持SpringBoot2.2.x版本
                    具体SpringBoot与SpringCloud版本对应关系参见：https://spring.io/projects/spring-cloud页面最下方的Release Trains
                 --&gt;
                &lt;!--&lt;version&gt;2.2.1.RELEASE&lt;/version&gt;--&gt;
                &lt;version&gt;${springboot.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${springcloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<h3 id="然后创建euraka-server模块">然后创建Euraka-server模块</h3>
<h4 id="1创建项目启动类">1.创建项目启动类</h4>
<pre><code class="language-java">@SpringBootApplication
//这是开启Eureka的注解
@EnableEurekaServer
public class EurekaApplication {
    public static void main(String[] args) throws IOException {
        SpringApplication.run(EurekaApplication.class,args);
    }
}

</code></pre>
<p>需要注意的是,这两个注解一个是统用的,一个是专用的.</p>
<pre><code class="language-java">@EnableDiscoveryClient
@EnableEurekaServer
</code></pre>
<h4 id="2然后配置下yml文件">2.然后配置下yml文件</h4>
<pre><code class="language-yml">server:
  port: 8761

spring:
  application:
    name: eureka-server
eureka:
  instance:
    prefer-ip-address: true
    hostname: localhost
  client:
 # 这个是要不要注册当前的服务注册到eureka中
    register-with-eureka: false
 # 是否从eureka中拉取服务表,即当前服务取注册中心拉取服务   
    fetch-registry: false
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nmBlNO8h-1576064827399)(D:\总结\springcloud\eureks名字.png)]</p>
<h4 id="3启动项目访问eureka日志中的地址出现管理界面">3.启动项目访问Eureka日志中的地址出现管理界面</h4>
<h3 id="创建服务提供者">创建服务提供者</h3>
<h4 id="1创建模块启动类">1.创建模块启动类</h4>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
public class EurekaProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaProviderApplication.class,args);
    }
}

</code></pre>
<h4 id="2配置yml文件">2.配置yml文件</h4>
<pre><code class="language-yml">spring:
  application:
    name: eureka-provider

eureka:
#  这个是客户端的配置
  client:
#    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
#    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: false
    service-url:
#      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
#      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
#      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
#    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
server:
  port: 8082
</code></pre>
<h4 id="3启动模块查看eureka控制home实例">3.启动模块,查看eureka控制home实例</h4>
<h3 id="创建consumer模块">创建consumer模块</h3>
<h4 id="1创建模块启动类-2">1.创建模块启动类</h4>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
public class EurekaConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaConsumerApplication.class,args);
    }
}
</code></pre>
<h4 id="2配置yml文件-2">2.配置yml文件</h4>
<pre><code class="language-yml">server:
  port: 8081

spring:
  application:
    name: eureka-consumer

eureka:
  client:
#    这个是要把服务注册到eureka-server的地址
    service-url: http://${eureka.instance.hostname}:8761/eureka/
#      这个是是否把自己的服务注册到注册中心
    register-with-eureka: true
#    这个是启动时是否拉取服务列表
    fetch-registry: false
  instance:
    hostname: localhost
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
#     在某些情况下，Eureka优先使用IP地址而不是主机名
#    。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    prefer-ip-address: true

</code></pre>
<h4 id="3启动模块查看服务是否注册成功">3.启动模块查看服务是否注册成功.</h4>
<h4 id="4访问localhost8081看服务有问题否">4.访问localhost:8081,看服务有问题否</h4>
<h2 id="出现的问题总结">出现的问题总结:</h2>
<h3 id="1ribbon的理解">1.Ribbon的理解</h3>
<p>​		**ribbon:**是在客户端的负载均衡,也就是说ribbon的负载均衡不在服务端,而是在客户端,这样它启动后就是先拉取服务,放在缓存中,,第二次用的就是缓存中的服务列表,然后即使服务器挂了,本地还有缓存中的服务列表,短暂的也不会影响客户端的使用</p>
<p>​		这样上面的配置就有问题:fetch-registry: false:表示不拉取服务,这样就会访问localhost:8081出现500错误,错误信息是没有instances可用,所以把fetch-registry: true即可则会正常访问</p>
<h1 id="eureka集群的搭建">Eureka集群的搭建</h1>
<p>模块的启动类:注意启动不同的节点要改变生产环境</p>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaCloudApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaCloudApplication.class,args);
    }
}

</code></pre>
<p>主要的配置文件如下:</p>
<p>这样节能直接启动:</p>
<p>​     <strong>注意:</strong> 1.启动不同的节点要改变生产环境</p>
<p>​				2.注意节点启动时会报错,因为还没启动完,最后一个启动不会报错,因为他们之间会互相拉取数据.</p>
<pre><code class="language-yml">spring:
  application:
    name:eureka-cloud-server
  profiles:
    active:

#eureka集群的搭建
eureka:
  client:
#    首先这两个要打开,一个是把当前服务注册到注册中心,一个是拉取其他注册中心的服务
#    高可用
    fetch-registry: true
    register-with-eureka: true
  instance:
    prefer-ip-address: true

---

spring:
  profiles: dev

eureka:
  client:
    service-url:
      defaultZone: http://ip2:port/eureka/,http://ip3:port/eureka/
  instance:
  instance:
    hostname: 主机的ip或主机名

---
spring:
  profiles: node1

eureka:
  client:
    service-url: 
      defaultZone: http://ip1:port/eureka/,http://ip3:port/eureka/
  instance:
    hostname: 主机的ip或主机名
---
spring:
  profiles: node2

eureka:
  client:
    service-url:
      defaultZone: http://ip1:port/eureka/,http://ip2:port/eureka/
  instance:
    hostname: 主机的ip或主机名
</code></pre>
<h1 id="spring-cloud">Spring-Cloud</h1>
<h2 id="netflix-feign组件">netflix---Feign(组件)</h2>
<h3 id="使用底层封装了httpclient">使用:底层封装了HttpClient</h3>
<h4 id="1添加依赖">1.添加依赖</h4>
<pre><code class="language-xml">      &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;
            &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

</code></pre>
<h4 id="2模块启动类">2.模块启动类</h4>
<pre><code class="language-java">@SpringBootApplication
//@EnableEurekaClient
@EnableFeignClients
public class EurekaFeignConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaFeignConsumerApplication.class,args);
    }
}

</code></pre>
<h4 id="3service层的使用">3.service层的使用</h4>
<pre><code class="language-java">@FeignClient(&quot;eureka-provider:8082&quot;)
@Service
public interface CalcService {
    @GetMapping(&quot;/calc/add/{num1}/{num2}&quot;)
    public ResponseInfo add(@PathVariable(&quot;num1&quot;) int num1, @PathVariable(&quot;num2&quot;) int num2);
}
</code></pre>
<p>4.controller层</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/calc&quot;)
@Slf4j
public class CalcController {


    @Autowired
    private CalcService calcService;

    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {

        System.out.println(num1+ &quot;    &quot; + num2);
        // 以前使用SpringMVC方式，直接通过IP+端口号来调用服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://localhost:8081/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        // 引入Ribbon后，通过微服务ID访问远程服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://eureka-provider:8082/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        ResponseInfo info = calcService.add(num1, num2);
//        ResponseInfo info = entity.getBody();
        Map data = (Map) info.getData();
        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);

        return &quot;index&quot;;
    }
}

</code></pre>
<p>4.yml的配置</p>
<pre><code class="language-yml">spring:
  application:
    name: eureka-feign-consumer

eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
server:
  port: 8088
  
feign:
  client:
    config:
      #      calc-service-provider:  这一级可以写具体的微服务名称或者default，default代表全局配置，影响所有微服务的调用
      default:
        connectTimeout: 1000
        readTimeout: 2000  
</code></pre>
<h4 id="5提供者和eureka服务的创建">5.提供者和Eureka服务的创建</h4>
<h1 id="spring-cloud-hystrix组件">Spring-Cloud---hystrix(组件)</h1>
<p><strong>两种方式分别是:hystrix和riboon的整合使用;hystrix和feign整合使用</strong></p>
<h2 id="hystrix熔断器和ribbon的整合使用">Hystrix(熔断器)和Ribbon的整合使用</h2>
<p>​		Hystrix和ribbon的使用主要是hystrix和ReatTemplate的使用.</p>
<p>什么是hystrix?</p>
<blockquote>
<p>在分布式环境中，许多服务依赖项中的一些不可避免地会失败。<br>
Hystrix是一个库，可通过添加延迟容错和容错逻辑来帮助您控制这些分布式服务之间的交互。<br>
Hystrix通过隔离服务之间的访问点，阻止它们之间的级联故障以及提供后备选项来实现这一目标，这些都可以提高系统的整体恢复能力</p>
</blockquote>
<blockquote>
<p>通俗的说Hystrix是Netflix公司开源的一个用于服务调用的断路器组件，给我们提供了包括服务熔断、降级、超时、资源隔离在内的完整解决方案。</p>
</blockquote>
<h2 id="具体使用">具体使用</h2>
<h3 id="1导入用到的依赖">1.导入用到的依赖</h3>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
            &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2启动类开启hystrix熔断">2.启动类开启Hystrix熔断</h3>
<pre><code class="language-java">@SpringBootApplication
@EnableCircuitBreaker //开启熔断
@EnableEurekaClient
public class HystrixRestTemplateApplication {
    @LoadBalanced //tibbon的使用,主要用来请求远程服务和负载均衡使用
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
    public static void main(String[] args) {
        SpringApplication.run(HystrixRestTemplateApplication.class,args);
    }
}

</code></pre>
<h3 id="3web控制层的使用">3.web控制层的使用</h3>
<pre><code class="language-java">/**
 * 计算器
 */
@Controller
@RequestMapping(&quot;/calc&quot;)
@Slf4j
public class CalcController {
    @Autowired
    private RestTemplate restTemplate;
    /**
     * 下面是熔断的使用
     * @param num1
     * @param num2
     * @param model
     * @return
     */
    @HystrixCommand(
            /**
             * 这是熔断点的定义
            */
            fallbackMethod = &quot;addFallback&quot;,
            /**
             * commandKey用于在Properties文件中配置此Command的参数，也可以直接用注解在这里配置参数
            */
            commandKey = &quot;calc_add_command&quot;
    )
    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {

        System.out.println(num1+ &quot;    &quot; + num2);
        // 以前使用SpringMVC方式，直接通过IP+端口号来调用服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://localhost:8081/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        // 引入Ribbon后，通过微服务ID访问远程服务
        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://eureka-provider:8082/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        ResponseInfo info = entity.getBody();
        Map data = (Map) info.getData();

        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        return &quot;index&quot;;
    }
    /**
     * 熔断方法,当服务发生熔断是调用此方法
     * @param num1
     * @param num2
     * @param model
     * @return
     */
    public String addFallback(@RequestParam int num1, @RequestParam int num2, Model model){
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        model.addAttribute(&quot;result&quot;, &quot;-1&quot;);
        return &quot;index&quot;;
    }
}
</code></pre>
<p><strong>注意</strong>:这里的 @HystrixCommand中的参数commandkey的使用是,用于在Properties文件中配置此Command的参数，也可以直接用注解在这里配置参数.</p>
<h3 id="4最重要的yml中的配置">4.最重要的yml中的配置</h3>
<pre><code class="language-yml">spring:
  application:
    name: eureka-consumer-rest_template-hystrix
    
eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    # hystrix中的核心配置
hystrix:
  command:
    calc_add_command:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
      circuitBreaker:
        requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
        sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
        errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
      metrics:
        rollingStats:
          timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s
server:
  port: 8099
</code></pre>
<h3 id="5启动项目测试">5.启动项目测试</h3>
<h2 id="hystrix和feign的整合使用">Hystrix和Feign的整合使用</h2>
<h3 id="1导入依赖">1.导入依赖</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2web控制层">2.web控制层</h3>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/calc&quot;)
@Slf4j
public class CalcController {
    @Autowired
    private CalcService calcService;

    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {
        System.out.println(num1+ &quot;    &quot; + num2);
        // 以前使用SpringMVC方式，直接通过IP+端口号来调用服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://localhost:8081/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        // 引入Ribbon后，通过微服务ID访问远程服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://eureka-provider:8082/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        ResponseInfo info = calcService.add(num1, num2);
//        ResponseInfo info = entity.getBody();
        Map data = (Map) info.getData();
        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        return &quot;index&quot;;
    }
}
</code></pre>
<h3 id="3service层">3.service层</h3>
<pre><code class="language-java">@FeignClient(value = &quot;eureka-provider:8082&quot;,fallback = FallbackClient.class)
@Service
public interface CalcService {
    @GetMapping(&quot;/calc/add/{num1}/{num2}&quot;)
    public ResponseInfo add(@PathVariable(&quot;num1&quot;) int num1,@PathVariable(&quot;num2&quot;) int num2);
}
</code></pre>
<p>需要注意的是fallback熔断方法的实现要和实现的接口的请求地址分开,因为实现接口会默认继承GetMappig 的请求地址,防止出现暧昧关系</p>
<p>熔断方法</p>
<pre><code class="language-java">@Component
@RequestMapping(&quot;/fallback&quot;)
public class FallbackClient implements CalcService {
    @Override
    public ResponseInfo add(int num1, int num2) {
        Map data = new HashMap();
        data.put(&quot;num1&quot;, num1);
        data.put(&quot;num2&quot;, num2);
        data.put(&quot;result&quot;, -1);
        ResponseInfo responseInfo = new ResponseInfo(203,  &quot;降级结果&quot;, data);
        return responseInfo;
    }
}
</code></pre>
<h3 id="4配置文件">4.配置文件</h3>
<pre><code class="language-yml">spring:
  application:
    name: eureka-consumer-feign-hystrix


eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}

hystrix:
  command:
#    default:  # 设置全局熔断参数
    CalcService#add(int,int): #设置某个feign client的熔断参数
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
        circuitBreaker:
          requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
          sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
          errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
        metrics:
          rollingStats:
            timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s

feign:
  client:
    config:
      #      calc-service-provider:  这一级可以写具体的微服务名称或者default，default代表全局配置，影响所有微服务的调用
      default:
        connectTimeout: 1000
        readTimeout: 2000
  hystrix:
    enabled: true
server:
  port: 8100

</code></pre>
<h3 id="5需要注意的问题">5.需要注意的问题</h3>
<p>​		在feign中默认的hystrix是默认关闭的,如果不打开的话,会出现找不到fallback的错误,错误类型是500.</p>
<h1 id="监控工具">监控工具</h1>
<h2 id="springboot-actuator">SpringBoot Actuator</h2>
<p>SpringBoot Actuactor是SpringBoot提供的一个监控工具，通过他我们可以看到应用运行工程中的很多有用的信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Enabled by default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">auditevents</td>
<td style="text-align:left">Exposes audit events information for the current application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">beans</td>
<td style="text-align:left">Displays a complete list of all the Spring beans in your application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">conditions</td>
<td style="text-align:left">Shows the conditions that were evaluated on configuration and auto-configuration classes and the reasons why they did or did not match.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">configprops</td>
<td style="text-align:left">Displays a collated list of all <code class="literal">@ConfigurationProperties</code>.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">env</td>
<td style="text-align:left">Exposes properties from Spring’s <code class="literal">ConfigurableEnvironment</code>.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">flyway</td>
<td style="text-align:left">Shows any Flyway database migrations that have been applied.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">health</td>
<td style="text-align:left">Shows application health information.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">httptrace</td>
<td style="text-align:left">Displays HTTP trace information (by default, the last 100 HTTP request-response exchanges).</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">info</td>
<td style="text-align:left">Displays arbitrary application info.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">loggers</td>
<td style="text-align:left">Shows and modifies the configuration of loggers in the application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">liquibase</td>
<td style="text-align:left">Shows any Liquibase database migrations that have been applied.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">metrics</td>
<td style="text-align:left">Shows ‘metrics’ information for the current application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">mappings</td>
<td style="text-align:left">Displays a collated list of all <code class="literal">@RequestMapping paths</code>.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">scheduledtasks</td>
<td style="text-align:left">Displays the scheduled tasks in your application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">sessions</td>
<td style="text-align:left">Allows retrieval and deletion of user sessions from a Spring Session-backed session store. Not available when using Spring Session’s support for reactive web applications.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">shutdown</td>
<td style="text-align:left">Lets the application be gracefully shutdown.</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">threaddump</td>
<td style="text-align:left">Performs a thread dump.</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<p><font color="orange">如果应用是一个Web应用（指引入了SpringMVC、Spring WebFlux或者Jersey），就可以用下面这些监控端点</font></p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Enabled by default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">heapdump</td>
<td style="text-align:left">Returns an hprof heap dump file.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">jolokia</td>
<td style="text-align:left">Exposes JMX beans over HTTP (when Jolokia is on the classpath, not available for WebFlux).</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">logfile</td>
<td style="text-align:left">Returns the contents of the logfile (if logging.file or logging.path properties have been set). Supports the use of the HTTP Range header to retrieve part of the log file’s content.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">prometheus</td>
<td style="text-align:left">Exposes metrics in a format that can be scraped by a Prometheus server.</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<p>除了上面列出来的，其他第三方模块还会提供一些特有的监控端点，如zuul提供的/routes</p>
<h1 id="springcloud-zuul路由网关">Springcloud-zuul(路由网关)</h1>
<h2 id="zuul介绍">Zuul介绍</h2>
<blockquote>
<p>Zuul是Netflx开源的微服务网关。可以和Eureka、Ribbon、Hystrix配合使用，一个主要的功能就是可以将后端众多的微服务屏蔽、整合，对前端提供一套统一的服务(有点像是后端的Facade)。</p>
</blockquote>
<p>Zuul提供了以下几项支持：</p>
<ul>
<li>认证安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</li>
<li>监控</li>
<li>动态路由: 动态将请求路由到不同后端集群</li>
<li>压力测试: 逐渐增加指向集群的流量，以了解性能</li>
<li>金丝雀测试: 灰度发布</li>
<li>流量控制: 为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>服务迁移</li>
<li>静态资源响应处理: 边缘位置进行响应，避免转发到内部集群</li>
</ul>
<h2 id="zuul用的地方是">zuul用的地方是</h2>
<p>一般用在服务的提供者</p>
<h3 id="1加依赖">1.加依赖</h3>
<pre><code class="language-xml">     &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="2创建springcloud-zuul">2.创建springcloud-zuul</h3>
<pre><code class="language-java">@SpringBootApplication
@EnableZuulProxy
@EnableEurekaClient
public class ZuulApplication {
    public static void main(String[] args) {
        SpringApplication.run(ZuulApplication.class, args);
    }

}
</code></pre>
<h3 id="3配置">3.配置</h3>
<pre><code class="language-yml">server:
  port: 10003
spring:
  application:
    name: zuul-server

eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
zuul:
  routes:
    # 这种方式配置路由规则：前面的key是微服务名称，后面是匹配路径
    #    calc-service-provider: /calcApi/**
    # 这种方式配置路由规则：第一级的key可以随便取（路由名称），下面可以配置更多key、value（相比上面一种配置更强大）
    calc-proxy:
      serviceId: eureka-provider # 有效的微服务名称
      path: /calc/**  # 访问路径
      strip-prefix: false # 是否在网关层面消耗掉指定服务的路由规则前缀
    #    taotao-rest-proxy:
    #      serviceId: taotao-rest
    #      path: /rest/**

</code></pre>
<p><strong>注意上上面的strip-prefix: 值的用法</strong></p>
<p>1.上面的strip-prefix: false设置false代表你访问**localhost:10003/calc/****会跳转到对应的服务是eureka-provider,然后到注册中心找到对应的服务,localhost:8082/calc/add/55/66</p>
<pre><code>2.   上面的strip-prefix: false设置false代表你访问localhost:**10003/calc/calc/****会跳转到对应的服务是eureka-provider,然后到注册中心找到对应的服务,localhost:8082/calc/add/55/66
</code></pre>
<h3 id="代理传统的服务">代理传统的服务</h3>
<p>配置如下</p>
<pre><code class="language-yml">server:
  port: 9100
spring:
  application:
    name: zuul-server

eureka:
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8761
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: node1.john.com

management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;

zuul:
  routes:
    # 这种方式配置路由规则：前面的key是微服务名称，后面是匹配路径
#    calc-service-provider: /calcApi/**
    # 这种方式配置路由规则：第一级的key可以随便取（路由名称），下面可以配置更多key、value（相比上面一种配置更强大）
    calc-proxy:
      serviceId: calc-service-provider # 有效的微服务名称
      path: /calc/**  # 访问路径
      strip-prefix: false # 是否在网关层面消耗掉指定服务的路由规则前缀
      #代理传统的服务:
#    taotao-rest-proxy:
#      serviceId: taotao-rest
#      path: /rest/**
    taotao-rest-proxy-forward: # 使用forward本地转发(就是将匹配到路由规则的请求，转发到网关本地应用中去处理)
      path: /rest-f/**
      url: forward:/rest
    # 比如浏览器访问：http://localhost:9100/api/rest-f/content/getall/89
    # 会被转发到：http://localhost:9100/rest/content/getall/89


  ignored-services: &quot;*&quot; # 忽略所有未显示配置路由规则的微服务
  prefix: /api
  strip-prefix: true  # 是否在网关层面消耗掉全局前缀


# 使用Zuul代理未接入Eureka的传统服务
taotao-rest:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList #如果不配置ServerList类型为ConfigurationBasedServerList的话就需要禁用ribbon的eureka支持
    ConnectTimeout: 500
    ReadTimeout: 2000
    listOfServers: http://localhost:8081

calc-service-provider:
  ribbon:
    ReadTimeout: 2000
    ConnectTimeout: 500

</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#springcloud%E4%B9%8Bnetflix">springcloud之Netflix</a>
<ul>
<li><a href="#netflix%E4%BD%93%E7%B3%BB%E7%AE%80%E4%BB%8B">Netflix体系简介</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98">核心成员</a>
<ul>
<li><a href="#netflix-eureka">Netflix Eureka</a></li>
<li><a href="#netflix-ribbon">Netflix Ribbon</a></li>
<li><a href="#netflix-hystrix">Netflix Hystrix</a></li>
<li><a href="#netflix-zuul">Netflix Zuul</a></li>
<li><a href="#netflix-archaius">Netflix Archaius</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#eureka%E5%92%8Cribbon">Eureka和Ribbon</a><br>
*
<ul>
<li><a href="#%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E7%9A%84eureka%E5%92%8Cribbon">单机模式的Eureka和Ribbon</a>
<ul>
<li><a href="#%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C">前置工作</a>
<ul>
<li><a href="#1%E9%A6%96%E5%85%88%E6%98%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8">1.首先是依赖的搭配使用</a></li>
<li><a href="#2%E7%84%B6%E5%90%8E%E5%86%8D%E5%85%AC%E7%94%A8%E6%A8%A1%E5%9D%97%E5%8A%A0%E4%BE%9D%E8%B5%96">2.然后再公用模块加依赖</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%84%B6%E5%90%8E%E5%88%9B%E5%BB%BAeuraka-server%E6%A8%A1%E5%9D%97">然后创建Euraka-server模块</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E7%B1%BB">1.创建项目启动类</a></li>
<li><a href="#2%E7%84%B6%E5%90%8E%E9%85%8D%E7%BD%AE%E4%B8%8Byml%E6%96%87%E4%BB%B6">2.然后配置下yml文件</a></li>
<li><a href="#3%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E8%AE%BF%E9%97%AEeureka%E6%97%A5%E5%BF%97%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%87%BA%E7%8E%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2">3.启动项目访问Eureka日志中的地址出现管理界面</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85">创建服务提供者</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E5%90%AF%E5%8A%A8%E7%B1%BB">1.创建模块启动类</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AEyml%E6%96%87%E4%BB%B6">2.配置yml文件</a></li>
<li><a href="#3%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%9F%A5%E7%9C%8Beureka%E6%8E%A7%E5%88%B6home%E5%AE%9E%E4%BE%8B">3.启动模块,查看eureka控制home实例</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BAconsumer%E6%A8%A1%E5%9D%97">创建consumer模块</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E5%90%AF%E5%8A%A8%E7%B1%BB-2">1.创建模块启动类</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AEyml%E6%96%87%E4%BB%B6-2">2.配置yml文件</a></li>
<li><a href="#3%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F">3.启动模块查看服务是否注册成功.</a></li>
<li><a href="#4%E8%AE%BF%E9%97%AElocalhost8081%E7%9C%8B%E6%9C%8D%E5%8A%A1%E6%9C%89%E9%97%AE%E9%A2%98%E5%90%A6">4.访问localhost:8081,看服务有问题否</a></li>
</ul>
</li>
<li><a href="#%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">出现的问题总结:</a>
<ul>
<li><a href="#1ribbon%E7%9A%84%E7%90%86%E8%A7%A3">1.Ribbon的理解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#eureka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA">Eureka集群的搭建</a></li>
<li><a href="#spring-cloud">Spring-Cloud</a>
<ul>
<li><a href="#netflix-feign%E7%BB%84%E4%BB%B6">netflix---Feign(组件)</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82%E5%B0%81%E8%A3%85%E4%BA%86httpclient">使用:底层封装了HttpClient</a>
<ul>
<li><a href="#1%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">1.添加依赖</a></li>
<li><a href="#2%E6%A8%A1%E5%9D%97%E5%90%AF%E5%8A%A8%E7%B1%BB">2.模块启动类</a></li>
<li><a href="#3service%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8">3.service层的使用</a></li>
<li><a href="#5%E6%8F%90%E4%BE%9B%E8%80%85%E5%92%8Ceureka%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA">5.提供者和Eureka服务的创建</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-cloud-hystrix%E7%BB%84%E4%BB%B6">Spring-Cloud---hystrix(组件)</a>
<ul>
<li><a href="#hystrix%E7%86%94%E6%96%AD%E5%99%A8%E5%92%8Cribbon%E7%9A%84%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8">Hystrix(熔断器)和Ribbon的整合使用</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8">具体使用</a>
<ul>
<li><a href="#1%E5%AF%BC%E5%85%A5%E7%94%A8%E5%88%B0%E7%9A%84%E4%BE%9D%E8%B5%96">1.导入用到的依赖</a></li>
<li><a href="#2%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%BC%80%E5%90%AFhystrix%E7%86%94%E6%96%AD">2.启动类开启Hystrix熔断</a></li>
<li><a href="#3web%E6%8E%A7%E5%88%B6%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8">3.web控制层的使用</a></li>
<li><a href="#4%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84yml%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE">4.最重要的yml中的配置</a></li>
<li><a href="#5%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95">5.启动项目测试</a></li>
</ul>
</li>
<li><a href="#hystrix%E5%92%8Cfeign%E7%9A%84%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8">Hystrix和Feign的整合使用</a>
<ul>
<li><a href="#1%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96">1.导入依赖</a></li>
<li><a href="#2web%E6%8E%A7%E5%88%B6%E5%B1%82">2.web控制层</a></li>
<li><a href="#3service%E5%B1%82">3.service层</a></li>
<li><a href="#4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">4.配置文件</a></li>
<li><a href="#5%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98">5.需要注意的问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7">监控工具</a>
<ul>
<li><a href="#springboot-actuator">SpringBoot Actuator</a></li>
</ul>
</li>
<li><a href="#springcloud-zuul%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3">Springcloud-zuul(路由网关)</a>
<ul>
<li><a href="#zuul%E4%BB%8B%E7%BB%8D">Zuul介绍</a></li>
<li><a href="#zuul%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9%E6%98%AF">zuul用的地方是</a>
<ul>
<li><a href="#1%E5%8A%A0%E4%BE%9D%E8%B5%96">1.加依赖</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BAspringcloud-zuul">2.创建springcloud-zuul</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AE">3.配置</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1">代理传统的服务</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yihuaikun.github.io/post/linux-de-ji-ben-ming-ling">
              <h3 class="post-title">
                Linux的基本命令
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://yihuaikun.github.io" target="_blank">YHK</a> | 
  <a class="rss" href="https://yihuaikun.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
