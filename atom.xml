<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yihuaikun.github.io</id>
    <title>向java工程师迈进</title>
    <updated>2019-12-12T13:07:22.247Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yihuaikun.github.io"/>
    <link rel="self" href="https://yihuaikun.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yihuaikun.github.io/images/avatar.png</logo>
    <icon>https://yihuaikun.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 向java工程师迈进</rights>
    <entry>
        <title type="html"><![CDATA[接入阿里大于短信服务]]></title>
        <id>https://yihuaikun.github.io/post/jie-ru-a-li-da-yu-duan-xin-fu-wu</id>
        <link href="https://yihuaikun.github.io/post/jie-ru-a-li-da-yu-duan-xin-fu-wu">
        </link>
        <updated>2019-12-12T12:35:11.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/cool_summer_moon/article/details/53648093">阿里云大于短信服务开发</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB入门]]></title>
        <id>https://yihuaikun.github.io/post/mongodb-ru-men</id>
        <link href="https://yihuaikun.github.io/post/mongodb-ru-men">
        </link>
        <updated>2019-12-12T12:29:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mongodb入门">MongoDB入门</h1>
<h2 id="什么是mongodb">什么是mongoDB?</h2>
<pre><code>	是一种面向文档的数据库管理系统,它是介于一个关系型数据库和非关系型数据库的之间的一种产品,MongoDb的功能丰富,它是一种支持类似JSON和BSON数据格式,既可以支持简单的数据格式,也可以存储复杂的数据类型.MongoDB最大的特点是它支持的查询语言非常强大,并且还支持数据建立索引.总体来说,mongDB是一款应用相当广泛的nosql型数据库
</code></pre>
<h2 id="mongodb的安装">MongoDB的安装</h2>
<h3 id="1下载地址是">1.下载地址是</h3>
<p><a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.9.tgz">mongodb下载地址</a></p>
<pre><code class="language-linux">wget  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.9.tgz
</code></pre>
<h3 id="2下载下来后解压缩">2.下载下来后解压缩</h3>
<pre><code class="language-linux">[root@iz2zejf0fjkrgyd7kckmfxz mongodb]# tar -zxvf mongodb-linux-x86_64-3.4.9.tgz
</code></pre>
<h3 id="3进入mongodb根目录创建db和logs">3.进入mongodb根目录创建db和logs</h3>
<pre><code class="language-linux">mkdir db
mkdir logs
</code></pre>
<h3 id="4进入bin目录配置配置文件在里面可能没有配置文件创建即可">4.进入bin目录配置配置文件,在,里面可能没有配置文件,创建即可</h3>
<pre><code class="language-linux">vim mongodb.conf
</code></pre>
<h3 id="5配置文件内容">5.配置文件内容</h3>
<pre><code class="language-linux">dbpath=/opt/mongodb/db #这个是自己的文件目录地址
logpath=/opt/mongodb/logs/mongodb.log #这个也是自己的文件目录地址
port=27017
fork=true
nohttpinterface=true
</code></pre>
<h3 id="6启动mongodb">6.启动mongodb</h3>
<pre><code class="language-linux">./mongod -f mongodb.conf
</code></pre>
<p>启动成功标识</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191205170726651.png" alt="在这里插入图片描述"></figure>
<h3 id="7客户端访问">7.客户端访问</h3>
<pre><code class="language-linux">./mongo 
</code></pre>
<p>访问成功界面</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2019120517074226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="8切换用户命令">8.切换用户命令</h3>
<pre><code class="language-linux">use 用户名
#退出客户端访问必须在admin用户下
use admin
db.shutdownServer()
</code></pre>
<h1 id="安全管理">安全管理</h1>
<p>上面我们所做的所有的操作都没有涉及到用户，我们在用 Oracle、MySQL 或者 MSSQL 时都有用户名密码需要登录才可以操作，MongoDB 中当然也有，但是需要我们手动添加。在添加之前，我们先来说说 MongoDB 中用户管理的几个特点：</p>
<blockquote>
<ol>
<li>MongoDB 中的账号是在某一个库里边进行设置的，我们在哪一个库里边进行设置，就要在哪一个库里边进行验证。</li>
<li>创建用户时，我们需要指定用户名、用户密码和用户角色，用户角色表示了该用户的权限。</li>
</ol>
</blockquote>
<h2 id="创建用户">创建用户</h2>
<p>给admin创建一个用户;</p>
<pre><code class="language-linux">use admin
db.createUser({user:&quot;root&quot;,pwd:&quot;123&quot;,roles:[{role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}]})
</code></pre>
<p>user 表示用户名，pwd 表示密码，role 表示角色，db 表示这个用户应用在哪个数据库上。用户的角色，有如下几种(<a href="https://www.cnblogs.com/shiyiwen/p/5552750.html">参考资料</a>)：</p>
<table>
<thead>
<tr>
<th style="text-align:left">角色名</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Read</td>
<td style="text-align:left">允许用户读取指定数据库</td>
</tr>
<tr>
<td style="text-align:left">readWrite</td>
<td style="text-align:left">允许用户读写指定数据库</td>
</tr>
<tr>
<td style="text-align:left">dbAdmin</td>
<td style="text-align:left">允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td>
</tr>
<tr>
<td style="text-align:left">userAdmin</td>
<td style="text-align:left">允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</td>
</tr>
<tr>
<td style="text-align:left">clusterAdmin</td>
<td style="text-align:left">只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</td>
</tr>
<tr>
<td style="text-align:left">readAnyDatabase</td>
<td style="text-align:left">只在admin数据库中可用，赋予用户所有数据库的读权限</td>
</tr>
<tr>
<td style="text-align:left">readWriteAnyDatabase</td>
<td style="text-align:left">只在admin数据库中可用，赋予用户所有数据库的读写权限</td>
</tr>
<tr>
<td style="text-align:left">userAdminAnyDatabase</td>
<td style="text-align:left">只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</td>
</tr>
<tr>
<td style="text-align:left">dbAdminAnyDatabase</td>
<td style="text-align:left">只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</td>
</tr>
<tr>
<td style="text-align:left">root</td>
<td style="text-align:left">只在admin数据库中可用。超级账号，超级权限</td>
</tr>
</tbody>
</table>
<p>创建用户成功后需要关闭mongodb服务,以security的方式启动.然后进入.查看dbs</p>
<pre><code class="language-linux">mongod -f /opt/mongodb/bin/mongodb.conf --auth
./mongo
show dbs
</code></pre>
<p>此时我们看到没有权限</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191205170801226.png" alt="在这里插入图片描述"></figure>
<p>此时我们需要先进入到 admin 数据库中，然后授权，操作如下：</p>
<pre><code class="language-linux">use admin
db.auth(&quot;root&quot;,&quot;123&quot;)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191205170819702.png" alt="在这里插入图片描述"></figure>
<p>auth 方法执行结果返回 1 表示认证成功。然后再去执行 show dbs 就可以看到预期结果了。此时我再在 sang 库下创建一个只读用户，如下：</p>
<pre><code class="language-linux">use sang
db.createUser({user:&quot;readuser&quot;,pwd:&quot;123&quot;,roles:[{role:&quot;read&quot;,db:&quot;sang&quot;}]})
</code></pre>
<p>创建成功之后，再按照上面的流程进入到 sang 库中，使用 readuser 用户进行认证，认证成功之后一切我们就可以在 sang 库中执行查询操作了，步骤如下：</p>
<pre><code>use sang
db.auth(&quot;readuser&quot;,&quot;123&quot;)
</code></pre>
<p>做完这两步之后再执行查询操作就没有任何问题了，但是此时如果执行插入操作会提示没有权限，那我们可以创建一个有读写功能的用户执行相应的操作，这里就不再赘述。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis]]></title>
        <id>https://yihuaikun.github.io/post/redis</id>
        <link href="https://yihuaikun.github.io/post/redis">
        </link>
        <updated>2019-12-04T15:38:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-redis介绍">1. redis介绍</h1>
<h2 id="11-什么是redis">1.1. 什么是redis</h2>
<blockquote>
<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求</p>
</blockquote>
<h3 id="redis支持的键值数据类型">Redis支持的键值数据类型</h3>
<p>字符串类型</p>
<p>散列类型  (对应Java中的Object，它主要用来存储对象)</p>
<p>列表类型  （List）</p>
<p>集合类型    (Set)</p>
<p>有序集合类型。 (TreeSet)</p>
<h2 id="12-redis的应用场景">1.2. redis的应用场景</h2>
<p>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）</p>
<p>分布式集群架构中的session分离。</p>
<p>聊天室的在线好友列表。</p>
<p>任务队列。（秒杀、抢购、12306等等）</p>
<p>应用排行榜。</p>
<p>网站访问统计。</p>
<p>数据过期处理（可以精确到毫秒）</p>
<h1 id="2-redis的安装">2. Redis的安装</h1>
<h2 id="21-在windows上安装">2.1 在Windows上安装</h2>
<p>Redis官方只提供了Linux和macos的版本，并没有提供Windows安装包，但是微软的github仓库中我们可以下载到Windows上可用的Redis程序包，但已经很久没有更新，建议仅用来作为开发练手，不要用于实际的生产环境中。</p>
<p>下载地址： https://github.com/microsoftarchive/redis/tags</p>
<p>下载后直接解压就可以用了</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191125091710786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h2 id="22-在linux上安装">2.2 在Linux上安装</h2>
<p>redis是C语言开发，建议在linux上运行，示例使用CentOS7作为安装环境。</p>
<ol>
<li>
<p>安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc</p>
<pre><code class="language-bash">yum install gcc-c++
</code></pre>
<blockquote>
<p>阿里云的CentOS7默认已经内置了gcc，可以跳过这一步</p>
</blockquote>
</li>
<li>
<p>下载redis</p>
<p>从官网下载</p>
<p>http://download.redis.io/releases/redis-5.0.5.tar.gz</p>
<p>将redis-5.0.5.tar.gz拷贝任意路径下，如 /home/john/opt/</p>
</li>
<li>
<p>解压源码</p>
<pre><code class="language-bash">cd /home/john/opt/
tar -zxvf redis-5.0.5.tar.gz  
</code></pre>
</li>
<li>
<p>进入解压后的目录进行编译安装</p>
<pre><code class="language-bash">cd /home/john/opt/redis-5.0.5/src
make # 编译源代码
make install  # 安装
# 上面两步也可以直接通过 make &amp;&amp; make install两步并一步执行
</code></pre>
<blockquote>
<p>Redis默认的安装目录是/usr/local/bin， 我们在执行make install命令时添加prefix参数可修改默认安装位置，如： make PREFIX=/usr/local/redis install</p>
</blockquote>
</li>
</ol>
<h1 id="3-redis单机启动">3. redis单机启动</h1>
<p>redis.conf是redis的配置文件，默认在redis源码包解压后的根目录有一份redis.conf文件，我们可将其拷贝一份到上一步中redis的安装目录</p>
<pre><code class="language-bash">cp /home/john/opt/redis-5.0.5/src/redis.conf /usr/local/bin
</code></pre>
<p>我们装完redis以后，默认的安装路径是/usr/local/bin，系统会自动来此目录寻找命令，所以我们不需要在配置环境变量，在任意目录都可以使用redis相关的命令，如redis-server、redis-cli</p>
<h2 id="31-前端模式启动">3.1.   前端模式启动</h2>
<p>启动命令：</p>
<pre><code class="language-bash">redis-server /usr/local/bin/redis.conf
</code></pre>
<p>通过上面的命令启动，redis将以前端模式启动，前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法。</p>
<h2 id="32-后端模式启动">3.2.   后端模式启动</h2>
<h3 id="321-开启远程连接">3.2.1 开启远程连接</h3>
<ul>
<li>注释掉 bind 127.0.0.1这行</li>
<li>关闭保护模式  将protected-mode yes 改成 protected-mode no</li>
</ul>
<h3 id="322-添加密码验证">3.2.2 添加密码验证</h3>
<p>放开 # requirepass foobared 这行注释，将后面的foobared改成你自己需要设置的密码</p>
<p>客户端连接时，需要添加-a 参数指定密码才能连上来。</p>
<h3 id="323-开启后台守护进程运行模式">3.2.3 开启后台守护进程运行模式</h3>
<p>将 # daemonize no 这行放开注释， 并且改成 yes， Redis server将以后台方式运行。</p>
<h3 id="324-指定日志文件">3.2.4 指定日志文件</h3>
<p>将 logfile &quot;&quot; 改成 logfile &quot;你需要的redis日志文件名称&quot;， 默认的空字符串代表输出到前端控制台（标准输出）</p>
<p>修改redis.conf配置文件， daemonize yes 以后端模式启动。</p>
<h3 id="325-启动">3.2.5 启动</h3>
<p>启动命令和前端启动一样，只不过控制台不会输出任何信息，而且命令结束，如果没有异常会马上退出。</p>
<h1 id="5-redis集群">5.   redis集群</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191125091753812.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h2 id="51-集群原理">5.1. 集群原理</h2>
<h3 id="511-redis-cluster架构图">5.1.1.   redis-cluster架构图</h3>
<p>架构细节:</p>
<ol>
<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效.</li>
<li>客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</li>
<li>redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value  Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</li>
</ol>
<h3 id="512-redis-cluster投票容错">5.1.2.   redis-cluster投票:容错</h3>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191125091815748.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<ol>
<li>投票过程是集群中所有master参与,如果半数以上master节点与master节点通信超过(cluster-node-timeout),认为当前master节点挂掉.</li>
<li>什么时候整个集群不可用(cluster_state:fail)?
<ol>
<li>如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态</li>
<li>如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态.</li>
</ol>
</li>
</ol>
<blockquote>
<p>当集群不可用时,所有对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误</p>
</blockquote>
<h2 id="53-创建集群">5.3. 创建集群</h2>
<h3 id="531-集群结点规划">5.3.1.   集群结点规划</h3>
<p>这里在同一台服务器用不同的端口表示不同的redis服务器(伪集群)，如下：</p>
<pre><code>主节点：192.168.101.3:7001 192.168.101.3:7002 192.168.101.3:7003

从节点：192.168.101.3:7004 192.168.101.3:7005 192.168.101.3:7006
</code></pre>
<h3 id="532-修改配置">5.3.2 修改配置</h3>
<p>修改redis.conf配置文件</p>
<pre><code class="language-conf">port 7001  # 将每个节点的端口号改成不一样的(因为同一台机器上一个端口只能被一个进程绑定)
cluster-enabled yes #是否开启集群模式
cluster-config-file nodes.conf	#集群配置文件名称
cluster-node-timeout 5000	#集群中节点间投票通信的超时时间
appendonly yes  #配置集群中当前节点仅开启AOF持久化模式
pidfile /var/run/redis_7001.pid  #将pid文件改成不同的名称，建议和当前节点的端口号对应
</code></pre>
<h3 id="533-创建集群目录">5.3.3 创建集群目录</h3>
<p>在/usr/local下创建redis-cluster目录，其下创建7001、7002。。7006目录，如下：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191125091842510.png" alt="在这里插入图片描述"></figure>
<p>将redis安装目录bin下的文件拷贝到每个700X目录内，并且将配置文件也拷贝一份到每个700X目录</p>
<pre><code class="language-bash">cp /usr/local/bin/redis/redis* /usr/local/redis-cluster/7001
cp /home/john/opt/redis-5.0.5/src/redis.conf /usr/local/redis-cluster/7001
</code></pre>
<p>修改每个700X目录下的redis.conf配置文件中的端口号和pid文件路径</p>
<h3 id="534-启动每个节点redis服务">5.3.4.   启动每个节点redis服务</h3>
<p>进入/usr/local/redis_cluster目录下，编写启动集群脚本：start_redis_cluster.sh</p>
<p>cd /usr/local/redis_cluster</p>
<p>vim start_redis_cluster.sh</p>
<pre><code class="language-bash">#!/bin/bash

work_dir=`pwd`

echo &quot;开始启动redis集群中的每个节点&quot;
for idx in {1..6}
do
    cd $work_dir
    cd &quot;./700$idx&quot; &amp;&amp; ./redis-server ./redis.conf
    if [ $? != 0 ] 
    then
        echo &quot;启动700$idx节点失败，停止启动集群&quot;
        exit 1
    fi  
    echo &quot;启动700$idx&quot;
done
echo &quot;所有集群节点启动完成&quot;

</code></pre>
<p>编辑完成后，按ESC切换到命令模式， 输入ZZ 或者 :wq保存退出。</p>
<p>启动Redis集群中所有节点</p>
<pre><code class="language-bash">./start_redis_cluster.sh 

</code></pre>
<p>查看redis进程：</p>
<p>ps aux | grep redis</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191125091920330.png" alt="在这里插入图片描述"></figure>
<h3 id="534-执行创建集群命令">5.3.4.   执行创建集群命令</h3>
<p>Redis 5开始，集群不需要依赖Ruby，官方直接提供了集群管理支持</p>
<pre><code class="language-bash">redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 \
127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 \
--cluster-replicas 1

</code></pre>
<blockquote>
<p>注意，这里用127.0.0.1仅适用于在本机练习集群搭建，真实环境下需要换成外公网IP，否则无法远程连接到你的redis集群</p>
</blockquote>
<p>命令说明：</p>
<p>redis集群至少需要3个主节点，每个主节点有一个从节点总共6个节点</p>
<p>--cluster-replicas指定为1表示为集群中每个master都指定一个slave，也就是说上面6个节点会有3个主节点和对应的3个从节点</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20191125092008537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>如果一切正常，最后会看到如下输出</p>
<pre><code class="language-bash">[OK] All 16384 slots covered.

</code></pre>
<h4 id="可能会遇到的错误">可能会遇到的错误</h4>
<p>错误一：</p>
<p>如果创建redis集群的时候，ip用的是127.0.0.1，那么你在用Java客户端远程操作Redis集群的时候，会死活连不上，一直是报<strong>127.0.0.1:7001</strong>无法连接</p>
<p>解决办法：创建Redis集群时，创建命令中传入的节点IP参数列表使用外部可以访问的IP</p>
<p>错误二：</p>
<p>如果执行时报如下错误：</p>
<p>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0</p>
<p>解决方法是删除生成的配置文件nodes.conf，如果不行则说明现在创建的节点包括了旧集群的结点信息，需要删除redis的持久化文件后再重启redis，比如：appendonly.aof、dump.rdb</p>
<h2 id="54-停止redis集群">5.4. 停止Redis集群</h2>
<p>在/usr/local/redis_cluster目录下，创建脚本文件：stop_redis_cluster.sh</p>
<p>输入以下内容：</p>
<pre><code class="language-bash">#!/bin/bash

work_dir=`pwd`

count=0
err_count=0
echo &quot;开始停止redis集群&quot;
for idx in {1..6}
do
    cd $work_dir
    cd &quot;./700$idx&quot; &amp;&amp; ./redis-cli -c -p &quot;700$idx&quot; shutdown
    if [ $? != 0 ] 
    then
        echo &quot;停止700$idx节点失败&quot;
        let err_count++
    fi  
    echo &quot;停止700$idx节点&quot;
    let count++
done
echo &quot;Redis集群一共有$count个节点，成功停止`expr $count - $err_count`个节点，有$err_count个节点停止失败.&quot;

</code></pre>
<p>执行此脚本可以停止redis集群</p>
<h2 id="55-查询集群信息">5.5. 查询集群信息</h2>
<p>集群创建成功登陆任意redis结点查询集群中的节点情况。</p>
<p>客户端以集群方式登陆：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191125092056434.png" alt="在这里插入图片描述"></figure>
<p>说明：</p>
<p><code>./redis-cli -c -h 192.168.101.3 -p 7001</code>，其中<code>-c</code>表示以集群方式连接redis，<code>-h</code>指定ip地址，<code>-p</code>指定端口号</p>
<h3 id="551-查看集群状态相关命令">5.5.1 查看集群状态相关命令</h3>
<p>cluster nodes 查询集群结点信息</p>
<p>cluster info 查询集群状态信息</p>
<h2 id="56-添加主节点">5.6. 添加主节点</h2>
<p>集群创建成功后可以向集群中添加节点，下面是添加一个master主节点</p>
<p>添加7007节点，参考集群节点规划章节添加一个“7007”目录作为新节点。</p>
<p>Redis 5 添加主节点命令：</p>
<p>语法：</p>
<pre><code>redis-cli –cluster add-node 要添加节点的ip:端口 集群中当前存在的任何一个节点的ip和端口

</code></pre>
<p>示例：</p>
<pre><code class="language-bash">redis-cli --cluster add-node 10.10.14.166:7006 10.10.14.166:7000

</code></pre>
<p>输出结果</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20191125092216235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>查看集群结点发现7007已添加到集群中：<br>
<img src="https://img-blog.csdnimg.cn/20191125092232728.png" alt="在这里插入图片描述"></p>
<p>注意：新添加的master node有以下两个特征</p>
<ol>
<li>由于它没有分配hash槽，所以该节点无法存储任何数据</li>
<li>由于它没有分配hash槽，所以在其他从节点要升级成主节点的过程中，该节点不参与投票（没有投票权）</li>
</ol>
<h3 id="561-hash槽重新分配">5.6.1.   hash槽重新分配</h3>
<p>添加完主节点需要对主节点进行hash槽分配这样该主节才可以存储数据。</p>
<p>redis集群有16384个槽，集群中的每个结点分配自已的槽，通过查看集群结点（cluster nodes命令）可以看到槽占用情况。 可以看到新添加的7007节点并没有分配到hash槽</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20191125092303198.png" alt="在这里插入图片描述"></figure>
<p>给刚添加的7007结点分配槽</p>
<p>第一步：连接上集群</p>
<pre><code class="language-bash">redis-cli --cluster reshard 127.0.0.1:7001  #（连接集群中任意一个可用结点就行）

</code></pre>
<p>第二步：输入要分配的槽数量</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20191125092413603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>输入 500表示分配500个槽</p>
<p>第三步：输入接收槽的结点id</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20191125092439556.png" alt="在这里插入图片描述"></figure>
<p>这里准备给7007分配槽，通过cluster nodes查看7007结点id为15b809eadae88955e36bcdbb8144f61bbbaf38fb</p>
<p>输入：15b809eadae88955e36bcdbb8144f61bbbaf38fb</p>
<p>第四步：输入源结点id<br>
<img src="https://img-blog.csdnimg.cn/20191125092457924.png" alt="在这里插入图片描述"></p>
<p>这里输入all</p>
<p>第五步：输入yes开始移动槽到目标结点id</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20191125092517748.png" alt="在这里插入图片描述"></figure>
<p>至此，新添加的7007 master节点的hash槽就分配完毕，可以存储数据了！</p>
<p>关于Redis 集群的hash slots相关知识，可以参阅：</p>
<p><a href="https://www.cnblogs.com/abc-begin/p/8203613.html">redis hash slot（虚拟桶）</a></p>
<p><a href="https://www.jianshu.com/p/fe7b7800473e">Redis Cluster及hash slot 算法</a></p>
<h2 id="57-添加从节点">5.7. 添加从节点</h2>
<p>集群创建成功后可以向集群中添加节点，下面是添加一个slave从节点。</p>
<p>添加7008从结点，将7008作为7007的从结点。</p>
<p>Redis 5中添加从节点命令：</p>
<p>语法：</p>
<pre><code class="language-bash">redis-cli –cluster add-node 要添加节点的ip:端口 集群中任意已有master的ip和端口 --cluster-slave [--cluster-master-id masterid]

</code></pre>
<p>示例：</p>
<p>添加一个从节点，不指定目标主节点</p>
<pre><code class="language-bash">redis-cli --cluster add-node 10.10.14.166:7008 10.10.14.166:7001 --cluster-slave

</code></pre>
<blockquote>
<p>注意：该命令只是向集群中添加了一个从节点，但并没有指名要作为哪个master node的从节点，Redis集群会将其添加到集群中随机挑一个从节点较少的master node上，作为其从节点</p>
</blockquote>
<p>添加一个从节点，并指定所属主节点</p>
<pre><code class="language-bash">redis-cli --cluster add-node 10.10.14.166:7008 10.10.14.166:7001 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e

</code></pre>
<blockquote>
<p>我们通过增加了一个cluster-master-id参数，指定从节点要添加到哪个主节点上。主节点的ID可以通过cluster nodes查看到</p>
</blockquote>
<p>注意：如果原来该结点在集群中的配置信息已经生成cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错：</p>
<p>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0</p>
<p>解决方法是删除生成的配置文件nodes.conf，删除后再执行添加从节点指令</p>
<p>查看集群中的结点可以发现，刚添加的7008为7007的从节点</p>
<h2 id="58-删除结点">5.8. 删除结点：</h2>
<p>Redis5以后删除节点命令：</p>
<p>语法：</p>
<pre><code class="language-bash">redis-cli --cluster del-node ip:port node_id

</code></pre>
<blockquote>
<p>注：上面的ip:port为集群中存在的任意节点，node_id是你要删除的节点的id</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-bash">redis-cli --cluster del-node 10.10.14.166:7001 d3b977fd46386db84fd85b9240deb602087c8617

</code></pre>
<p>删除已经占有hash槽的结点会失败，报错如下：</p>
<p>[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again.</p>
<p>需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）。</p>
<h1 id="6-redis持久化策略">6. Redis持久化策略</h1>
<h2 id="61-rdb快照模式">6.1 RDB快照模式</h2>
<p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p>
<h3 id="611-工作步骤">6.1.1 工作步骤</h3>
<ol>
<li>Redis forks；</li>
<li>子进程开始将数据写到临时RDB文件中；</li>
<li>当子进程完成写RDB文件，用新文件替换老文件；</li>
<li>当RedisServer重新启动时，读取RDB文件恢复到内存中。</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20191125092749581.png" alt="在这里插入图片描述"></figure>
<h3 id="612-配置参数">6.1.2 配置参数</h3>
<pre><code>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。

# save &quot;&quot;  			 # 将上面三个配置注释掉，只保留一个save &quot;&quot;， 代表禁用RDB快照模式

</code></pre>
<h2 id="62-aof模式">6.2 AOF模式</h2>
<p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，</p>
<p>Redis就不是一个合适的选择。</p>
<p>Append-only-file 模式是另一种选择。</p>
<p>你可以在配置文件中打开AOF模式</p>
<h3 id="621-工作步骤">6.2.1 工作步骤</h3>
<ol>
<li>Redis客户端发送读写命令</li>
<li>RedisServer接收并执行命令，同时同步记录命令到AOF文件中</li>
<li>Redis重新启动时读取AOF文件，执行其中每一条指令完成数据恢复</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20191125092809644.png" alt="在这里插入图片描述"></figure>
<h3 id="622-配置参数">6.2.2 配置参数</h3>
<pre><code># appendfsync always    # 命令过来后，立刻写入AOF文件（会强制flush操作系统IO缓冲）
appendfsync everysec	# 默认策略， 每秒钟将缓存的命令写入到AOF文件中
# appendfsync no        # 关闭AOF备份

</code></pre>
<h2 id="63-rdb模式与aof模式的对比">6.3 RDB模式与AOF模式的对比</h2>
<h3 id="631-rdb模式的优点">6.3.1 RDB模式的优点</h3>
<ol>
<li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li>
<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li>
<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>
</ol>
<h3 id="632-rdb模式的缺点">6.3.2 RDB模式的缺点</h3>
<ol>
<li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ol>
<h3 id="633-aof模式的优点">6.3.3 AOF模式的优点</h3>
<ol>
<li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li>
<li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li>
<li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li>
</ol>
<h3 id="634-aof模式的缺点">6.3.4 AOF模式的缺点</h3>
<ol>
<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li>
</ol>
<blockquote>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
</blockquote>
<blockquote>
<h4 id="如果rdb文件和aof同时存在当redis重启的时候会优先载入aof文件来恢复原始的数据因为在通常情况下aof文件保存的数据集要比rdb文件完整">如果RDB文件和AOF同时存在，当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件完整</h4>
</blockquote>
<h1 id="7-通过springboot操作redis">7. 通过SpringBoot操作redis</h1>
<p>注： 下面的教程以最新的SpringBoot版本 2.2.0为例</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
&lt;/parent&gt;

</code></pre>
<h2 id="71-sringboot操作单机版redis">7.1. SringBoot操作单机版Redis</h2>
<h3 id="711-引入依赖">7.1.1   引入依赖</h3>
<pre><code class="language-xml">&lt;!-- SpringBoot2以后，默认的redis客户端已经由jedis改成了lettuce，下面依赖会把lettuce-core也添加进来 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- 如果项目中用到了redis连接池，需要添加如下依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<h3 id="712-springboot配置">7.1.2   SpringBoot配置</h3>
<p>application.yml</p>
<pre><code class="language-yml">spring:
    redis:
    host: www.taotao.com
#    port: 6379		# 如果端口号不是默认端口需要制定
#    password: xxx	# 如果redis服务端开启了口令验证，需要添加
    lettuce:
      pool:			# 如果使用redis连接池，需要添加apche的common-pool2依赖
        max-idle: 2
        max-wait: 1000ms

</code></pre>
<h3 id="713-java代码">7.1.3.   Java代码</h3>
<p>通过创建单实例jedis对象连接redis服务，如下代码：</p>
<pre><code class="language-java">@Slf4j
@SpringBootTest
public class TestRedisClient {

   @Autowired
   private StringRedisTemplate redisTemplate;

   @Test
   public void testRedis() {
      Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;);
      log.info(&quot;操作前存在的keys: &quot; + keys);

      String key = &quot;lanou_F4&quot;;

      redisTemplate.opsForList().rightPushAll(key, new String[]{&quot;宋超&quot;, &quot;国胜&quot;, &quot;国伟&quot;, &quot;高飞&quot;});

      long size = redisTemplate.opsForList().size(key);
      log.info(&quot;当前&quot;+key+&quot;值的数量： &quot; + size);

      List&lt;String&gt; values = redisTemplate.opsForList().range(key, 0, size);
      log.info(&quot;当前&quot; + key +&quot;的值： &quot; + values);

      keys = redisTemplate.keys(&quot;*&quot;);
      log.info(&quot;操作后存在的keys: &quot; + keys);
   }
}

</code></pre>
<h2 id="72-springboot操作redis集群">7.2. SpringBoot操作Redis集群</h2>
<h3 id="721-引入依赖">7.2.1. 引入依赖</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;!-- 添加spring-boot-starter-data-redis依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;!-- 排除掉lettuce客户端相关依赖 --&gt;
            &lt;!-- lettuce客户端连接阿里云上自建的redis集群会有连接超时的问题 --&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- 替换成jedis客户端 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- redis连接池依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;

</code></pre>
<h3 id="722-springboot配置">7.2.2. SpringBoot配置</h3>
<p>application.yml</p>
<pre><code class="language-yml">spring:
  redis:
    jedis:
      pool: # 配置redis连接池相关参数
        max-idle: 2
        max-active: 10
        min-idle: 1
    cluster:
      nodes: teacher.lanou.com:7001,teacher.lanou.com:7002,teacher.lanou.com:7003,teacher.lanou.com:7004,teacher.lanou.com:7005,teacher.lanou.com:7006

</code></pre>
<h3 id="723-java代码">7.2.3. Java代码</h3>
<pre><code class="language-java">@SpringBootTest
class SpringbootRedisApplicationTests {

    @Autowired
    private StringRedisTemplate redisTemplate;


    @Test
    public void testPutKV() {
        ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
        ops.set(&quot;name&quot;, &quot;张三&quot;);
        String name = ops.get(&quot;name&quot;);
        Assertions.assertEquals(&quot;张三&quot;, name, &quot;应该返回张三&quot;);
    }

    @Test
    public void testOpsForList() {
        ListOperations&lt;String, String&gt; ops = redisTemplate.opsForList();
        ops.rightPush(&quot;yanfa3&quot;, &quot;王康健&quot;);
        ops.leftPush(&quot;yanfa3&quot;, &quot;于漫漫&quot;);
        ops.rightPushAll(&quot;yanfa3&quot;, &quot;李光&quot;, &quot;星辰&quot;, &quot;鹏杰&quot;, &quot;士军&quot;);

        Assertions.assertEquals(6, ops.size(&quot;yanfa3&quot;), &quot;应该是由6个元素才对&quot;);

        List&lt;String&gt; stuNames = ops.range(&quot;yanfa3&quot;, 0, -1);
        stuNames.forEach((v) -&gt; {
            System.out.println(v);
        });

    }
}

</code></pre>
<blockquote>
<p>集群模式只是依赖和配置不同，在代码中使用的API没有什么区别</p>
</blockquote>
<h2 id="73-外部连接不上redis的解决方法">7.3. 外部连接不上redis的解决方法</h2>
<p>由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。</p>
<p>查看防火墙状态：sevice iptables status</p>
<p>关闭防火墙命令：sevice iptables stop</p>
<p>如果是修改防火墙规则，可以修改：/etc/sysconfig/iptables文件</p>
<h1 id="8-系统添加缓存逻辑示例">8.   系统添加缓存逻辑示例</h1>
<p>添加缓存逻辑的原则：缓存逻辑不能影响正常的业务逻辑执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[问题!!]]></title>
        <id>https://yihuaikun.github.io/post/wen-ti</id>
        <link href="https://yihuaikun.github.io/post/wen-ti">
        </link>
        <updated>2019-12-04T05:32:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-cloud之eureka和ribbon使用问题">spring-cloud之eureka和ribbon使用问题</h1>
<h2 id="提供服务层端">提供服务层端</h2>
<pre><code class="language-java">@Service
@Slf4j
public class ContentServiceImpl implements ContentService {
    @Autowired
    private TbContentMapper tbContentMapper;
    @Autowired
    private CacheManagerService cacheManagerService;
    @Autowired
    private RedisTemplate redisTemplate;
    @Override
    public TaotaoResult getContent(Long cId) {
        List&lt;TbContent&gt; tbContents = cacheManagerService.getTbContentFromCache(cId);
        /**
         * 如果缓存中没有数据就从数据库中查
         * 查完之后将数据放入缓存,以便下次查找
         */
        if(tbContents == null){
            TbContentExample tbContentExample = new TbContentExample();
            TbContentExample.Criteria criteria = tbContentExample.createCriteria();
            criteria.andCategoryIdEqualTo(cId);
            tbContents = tbContentMapper.selectByExampleWithBLOBs(tbContentExample);
            /**
             * 将数据放入缓存
             */
            cacheManagerService.pushTbContent2Cache(cId,tbContents);
        }
        for(TbContent tbContent : tbContents){
            System.out.println(tbContent.toString());
        }
        return TaotaoResult.ok(tbContents);
    }
}

</code></pre>
<p>上面是提供服务的服务层</p>
<p>下面是提供服务的web控制层</p>
<pre><code class="language-java">@RestController
public class ContentController {
    @Autowired
    private ContentService  contentService;
    @GetMapping(&quot;/content/{cId}&quot;)
    public TaotaoResult getContent(@PathVariable Long cId){
        TaotaoResult taotaoResult = contentService.getContent(cId);
        return taotaoResult;
    }
}
</code></pre>
<p>我们把返回的结果封装在一个对象中,然后TaotaoResult的data字段我们在服务层用list存进去</p>
<h2 id="消费端">消费端</h2>
<pre><code class="language-java">@Service
@PropertySource(&quot;classpath:resources.properties&quot;)
public class AdServiceImpl implements AdService {
    /**
     * '
     * ribbon的方式
     */
    @Autowired
    private RestTemplate restTemplate;
    @Value(&quot;${INDEX_ADI_URL}&quot;)
    private String INDEX_ADI_URL;
    @Override
    public String getAdItemList() {
        //调用服务层的查询打广告的数据
        //发起http的Get请求
//        String result = HttpUtil.doGet(REST_BASE_URL+INDEX_ADI_URL);
        TaotaoResult taotaoResult = restTemplate.getForObject(&quot;http://taotao-rest-provider:8081&quot; + INDEX_ADI_URL, TaotaoResult.class);
//        System.out.println(taotaoResult.toString());
        String dataJson = JsonUtils.objectToJson(taotaoResult.getData());
        List&lt;TbContent&gt; contentList = JsonUtils.jsonToList(dataJson, TbContent.class);
        List&lt;ADItem&gt; adItemList = new ArrayList&lt;&gt;();
        for (TbContent tbContent : contentList) {
            ADItem adItem = new ADItem();
            adItem.setHeight(240);
            adItem.setWidth(670);
            adItem.setSrc(tbContent.getPic());
            adItem.setHeightB(240);
            adItem.setWidthB(550);
            adItem.setSrcB(tbContent.getPic2());
            adItem.setSrcB(tbContent.getPic2());
            adItem.setAlt(tbContent.getTitleDesc());
            adItem.setHref(tbContent.getUrl());
            adItemList.add(adItem);
        }
        return JsonUtils.objectToJson(adItemList);
    }
}
</code></pre>
<p>返回来的TaotaoResult的data字段还是ArrayList类型,但是ArrayLIst里面的每个是以LinkedhashMap存储的,就像下面这样拆分</p>
<pre><code class="language-java">		ArrayList arrayList = new ArrayList();
        LinkedHashMap map = new LinkedHashMap();
        map.put(&quot;id&quot;,101);
        map.put(&quot;name&quot;,&quot;张三&quot;);
        map.put(&quot;age&quot;,24);
        LinkedHashMap map1 = new LinkedHashMap();
        map1.put(&quot;id&quot;,102);
        map1.put(&quot;name&quot;,&quot;张三&quot;);
        map1.put(&quot;age&quot;,2);
        arrayList.add(map);
        arrayList.add(map1);
        System.out.println(arrayList);
</code></pre>
<p>所以直接用会报类型转换异常:LinkedHashMap  不能转换成某一个bean对象</p>
<p>正确的写法是</p>
<pre><code class="language-java">@Service
@PropertySource(&quot;classpath:resources.properties&quot;)
public class AdServiceImpl implements AdService {
    /**
     * '
     * ribbon的方式
     */
    @Autowired
    private RestTemplate restTemplate;
    @Value(&quot;${INDEX_ADI_URL}&quot;)
    private String INDEX_ADI_URL;
    @Override
    public String getAdItemList() {
        //调用服务层的查询打广告的数据
        //发起http的Get请求
//        String result = HttpUtil.doGet(REST_BASE_URL+INDEX_ADI_URL);
//        TaotaoResult taotaoResult = restTemplate.getForObject(&quot;http://taotao-rest-provider:8081&quot; + INDEX_ADI_URL, TaotaoResult.class);
//        String result = restTemplate.getForObject(&quot;http://taotao-rest-provider:8081&quot; + INDEX_ADI_URL, String.class);
        String result = restTemplate.getForObject(&quot;http://taotao-rest-provider&quot; + INDEX_ADI_URL, String.class);
        System.out.println(result);
        //        System.out.println(taotaoResult.toString());
        TaotaoResult taotaoResult = TaotaoResult.formatToList(result, TbContent.class);
//        System.out.println(taotaoResult.getData().getClass());
        List&lt;TbContent&gt; contentList = (List&lt;TbContent&gt;) taotaoResult.getData();
       /* String dataJson = JsonUtils.objectToJson(taotaoResult.getData());
        List&lt;TbContent&gt; contentList = JsonUtils.jsonToList(dataJson, TbContent.class);*/
        List&lt;ADItem&gt; adItemList = new ArrayList&lt;&gt;();
        for (TbContent tbContent : contentList) {
            ADItem adItem = new ADItem();
            adItem.setHeight(240);
            adItem.setWidth(670);
            adItem.setSrc(tbContent.getPic());
            adItem.setHeightB(240);
            adItem.setWidthB(550);
            adItem.setSrcB(tbContent.getPic2());
            adItem.setSrcB(tbContent.getPic2());
            adItem.setAlt(tbContent.getTitleDesc());
            adItem.setHref(tbContent.getUrl());
            adItemList.add(adItem);
        }
        return JsonUtils.objectToJson(adItemList);
    }
}

</code></pre>
<p><strong>直接把上面的data数据转换成json串,然后再转bean对象,还有就是服务不要写端口号,注册中心有端口号,不然没办法做客户端的负载均衡.</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单点登陆与redis集群缓存]]></title>
        <id>https://yihuaikun.github.io/post/dan-dian-deng-lu-yu-redis-ji-qun-huan-cun</id>
        <link href="https://yihuaikun.github.io/post/dan-dian-deng-lu-yu-redis-ji-qun-huan-cun">
        </link>
        <updated>2019-12-02T09:48:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单点登录sso">单点登录SSO</h1>
<p>​		单点登录:SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。</p>
<p>​		单点登录解决的问题:分布式session的共享问题,简单的说是解决了一个服务器一登陆的问题,实现多功能系统的一次登陆可访问多个服务的问题.</p>
<h2 id="环境的搭配">环境的搭配</h2>
<p>需要的依赖</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
            &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
            &lt;version&gt;3.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.62&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>1.redis集群的搭建</p>
<p>2.在java中的配置</p>
<pre><code class="language-yml">server:
  port: 10000
spring:
  datasource:
    username: root
    url: jdbc:mysql://localhost:3306/taotao?characterEncoding=utf8&amp;serverTimezone=UTC
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    #    redis.cluster集群的节点
    cluster:
      nodes: 
      # 这里写你的redis集群的ip和端口号以&quot;,&quot;分割
    jedis:
      pool:
        #      连接池最大数量
        max-active: 10
        #        连接池最小空闲连接
        min-idle: 1
        max-idle: 2
        #        连接池最大阻塞时间
        max-wait: -1
    password: xxxxx
    host: redis集群的ip地址
    timeout: 1000
    commandTimeout: 5000
</code></pre>
<p>3.在java中的配置文件</p>
<pre><code class="language-java">package com.sso.taotaossostudying;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.JedisCluster;
import redis.clients.jedis.JedisPoolConfig;

import java.util.HashSet;
import java.util.Set;

@Configuration
@ConditionalOnClass({JedisCluster.class})
@Component
public class RedisConfig {
    @Value(&quot;${spring.redis.cluster.nodes}&quot;)
    private String clusterNodes;
    @Value(&quot;${spring.redis.password}&quot;)
    private String password;
    @Value(&quot;${spring.redis.timeout}&quot;)
    private int timeout;
    @Value(&quot;${spring.redis.commandTimeout}&quot;)
    private int commandTimeout;
    @Bean
    public JedisCluster getJedisCluster() {
        String[] cNodes = clusterNodes.split(&quot;,&quot;);
        Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();
        //分割出集群节点
        for (String node : cNodes) {
            String[] hp = node.split(&quot;:&quot;);
            nodes.add(new HostAndPort(hp[0], Integer.parseInt(hp[1])));
        }
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        //创建集群对象。没有密码的请使用这一个
        // JedisCluster jedisCluster = new JedisCluster(nodes,commandTimeout);
        //有密码的请使用这一个。 我这里是redis有密码的所以我使用的这一个
        return new JedisCluster(nodes,commandTimeout,commandTimeout,5,password, jedisPoolConfig);
    }
}

</code></pre>
<p>ps:需要注意的是上面解决了jedis和jediscluster的一些问题得到的配置,redis集群加密的配置.</p>
<h2 id="单点登陆流程图">单点登陆流程图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191125090924348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h2 id="代码实现方面">代码实现方面</h2>
<h3 id="登陆界面的实现">登陆界面的实现</h3>
<pre><code class="language-java">@Controller
public class LoginUriController {
    @RequestMapping(&quot;/user/login&quot;)
    public String uritoLogin(HttpServletRequest req, @RequestParam(required = false) String url , Model model){
        try {
            req.setCharacterEncoding(&quot;utf-8&quot;);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        System.out.println(url);
        //把请求的uri放进来用于登陆成功后返回登陆时的页面
        model.addAttribute(&quot;url&quot;,url);
        return &quot;login&quot;;
    }
}

</code></pre>
<p>需要注意的是:</p>
<p>​	<strong>url和uri的区别:</strong></p>
<p>​		1.url在java中指是请求的全路径,uri指的是请求lujing,及handler上面的拦截路径</p>
<p>​		2.URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。而URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<p>​	<strong>一定要获得请求的路径</strong></p>
<p>​		获得请求的路径,通过location.href=xxx.xxx.com,来返回登陆处的功能,用户体验更好一些,</p>
<p>京东,淘宝都是这样做的.以参数的方式来获得从哪里得到发起请求的地址url,然后登陆后重新回到登陆处,比如去购物车去付款发现没登陆账号,然后去登陆,登陆后重新回到支付的页面进行购物.</p>
<h3 id="前端部分">前端部分</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://thymeleaf.org&quot; &gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登陆界面&lt;/title&gt;
&lt;/head&gt;
&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;body&gt;
&lt;form action=&quot;/login&quot;&gt;
    用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;/br&gt;
    密码:   &lt;input type=&quot;password&quot; name=&quot;password&quot; &gt; &lt;/br&gt;
    &lt;input type=&quot;submit&quot;&gt; &lt;a href=&quot;register.html&quot;&gt;注册&lt;/a&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;script&gt;
    //注意这里的thymeleaf的取值方式
    var url = $(&quot;#uri&quot;).val();
    console.log(url)
    function login() {
        var data = $(&quot;form&quot;).serialize();
        console.log(data);
        $.getJSON(&quot;/login&quot;,data,function (ret) {
            if(ret.status == 200){
                if(url == undefined){
                    location.href = &quot;http://localhost:10001&quot;;
                }else{
                    location.href = url;
                }
            }else{
                alert(ret.msg);
            }
        })
    }
    $(&quot;form&quot;).submit( function () {
        login();
        return false;
    } );
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>需要注意的是:</p>
<p>1.注意ajax的使用</p>
<p>2.登陆按钮的禁止跳转</p>
<p>3.前端做非空和非法判断</p>
<h3 id="登陆信息的处理">登陆信息的处理</h3>
<p>controller层的处理</p>
<pre><code class="language-java"> @RequestMapping(&quot;/login&quot;)
    public SSOResult login(String username, String password, HttpServletResponse resp){
        return loginService.login(username,password,resp);
    }
</code></pre>
<p>需要注意的是:</p>
<p>​	<strong>要把用户信息保存在session或cookie中,需要用到HttpServletResponse的对象</strong></p>
<p>service层对信息的处理</p>
<p>1.校验用户信息的正确性(即密码的校验需要连接数据库),正确后生成token(UUID)</p>
<p>2.把用户信息封装成对象(可以用md5堆成加密对用户信息加密),然后放到redis中</p>
<p><strong>注意</strong>:最好不要把密码放进去,因为上面已经验证过密码的正确性,所以最好就是把用户不隐私的信息放进去即可.token做key,用户对像做value</p>
<p>3.把token放到cookie中即可.</p>
<p>​		注意:cookie是在分布式的一级域名下,达到系统共享,访问其他服务,能从cookie中拿到token,然后去redis中拿用户信息.</p>
<p>4.需要注意的还有就是cookie和redis的有效期的设置,redis对内存要求比较高,这样的话我们对redis处理应该细致化.cookie中的token能否有效取决于redis中(token,用户对象)是否存在.不存在就失效或连接超时,需要重新登陆.</p>
<pre><code class="language-java">    @Override
    public SSOResult login(String username, String password, HttpServletResponse resp) {
        /**
         * 去数据库查找数据
         */
        if(StringUtils.isBlank(username) || StringUtils.isBlank(password)){
            return new SSOResult(&quot;用户名或密码不能为空&quot;,500);
        }
        if(StringUtils.isBlank(username)){
            return new SSOResult(&quot;用户名不能为空&quot;,500);
        }
        if(StringUtils.equals(username,&quot;zahngsan&quot;) &amp;&amp; !StringUtils.equals(password,&quot;123456&quot;)){
            return new SSOResult(&quot;密码不正确&quot;,500);
        }
        /**
         * 登陆成功后封装数据
         */
        //设置token
        String token = UUID.randomUUID().toString();
        UserInfo userInfo= new UserInfo();
        userInfo.setNickname(&quot;laozhang&quot;);
        userInfo.setUsername(&quot;zhangsan&quot;);

        String user = JSON.toJSONString(userInfo);

        //一般情况下不把password放在redis中,不安全
       // userInfo.setPassword(&quot;123456&quot;);
        jedis.setex(token,60,user);

        /**
         * 将token放入cookie,cookie的domain一般是一级域名下
         * 如果不知道domain是什么,启动一下项目,去application中找一下就行
         * 只是把token放到cookie中,然后其他服务用到,只能拿token去redis中拿数据,
         * 如果redis的keyshixiao了,那就要重新返回登陆界面重新登陆
         */
        Cookie tokenCookie = new Cookie(&quot;token&quot;,token);
        tokenCookie.setDomain(&quot;localhost&quot;);
        tokenCookie.setMaxAge(60);
        resp.addCookie(tokenCookie);
        return new SSOResult(&quot;登陆成功&quot;,200);
    }

</code></pre>
<p>总结:这里,面最后的返回码和上边前端相吻合,通过后处理后 返回到登陆时的界面.</p>
<p><strong>到此简单的登陆就做好了,对单点登陆应用是在拦截器中的使用</strong></p>
<h3 id="登陆的效果实现">登陆的效果实现</h3>
<p>在门户系统中开登陆的口</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;http://localhost:10000/user/login&quot;&gt;登陆&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>服务到sso做上边的登陆处理之后回到门户</p>
<h2 id="比如订单的处理">比如订单的处理</h2>
<p>看订单我们需要有用户信息,然后验证通过后才能看订单,这样我们就要在拦截器中来让用户的看订单请求去sso拿用户信息</p>
<p>请求接口前端:</p>
<pre><code class="language-java">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--请求查看订单页面--&gt;
&lt;a href=&quot;/order/all&quot; &gt;查看订单&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>拦截这个路径处理用户身份信息,这是我们只有能唯一得到的时存储用户信息的cookie</p>
<p>拦截器的配置</p>
<pre><code class="language-java">@SpringBootApplication
public class SsoDoorApplication implements WebMvcConfigurer 
    @Autowired
    private OrderInterceptor orderInterceptor;
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(orderInterceptor).addPathPatterns(&quot;/order/**&quot;);
    }
    public static void main(String[] args) {
        SpringApplication.run(SsoDoorApplication.class, args);
    }
}


</code></pre>
<p>在拦截器中的请求</p>
<pre><code class="language-java">@Component
public class OrderInterceptor implements HandlerInterceptor {
    private String url = &quot;http://localhost:10000/user/login&quot;;
    private String getDataUrl = &quot;http://localhost:10000/get_user_by_token&quot;;
    @Autowired
    private RestTemplate restTemplate;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        StringBuffer requestURL = request.getRequestURL();
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter writer = response.getWriter();
        /**
         * 拿到cookie获得token
         * 两种结果cookie过期,然后重定向到登陆界面
         * token存在,拿着token去sso服务要用户信息
         */
        Cookie[] cookies = request.getCookies();
        String token = null;
        String restUri = url + &quot;?&quot; + requestURL;
        if (cookies == null) {
            writer.println(&quot;&lt;script&gt; alert('你还没登陆,请登陆!');location.href='&quot; + restUri + &quot;'&lt;/script&gt;&quot;);
        } else {
            for (Cookie cookie : cookies) {
                /**
                 *拿到token
                 */
                if (cookie.getName().equals(&quot;token&quot;)) {
                    token = cookie.getValue();
                    break;
                } else {
                    continue;
                }
            }
        }

        if (token == null) {
            writer.println(&quot;&lt;script&gt; alert('会话超时,请重新登陆!');location.href='&quot; + restUri + &quot;'&lt;/script&gt;&quot;);
            return false;
        }
        /**
         * 判断token是否存在
         */
        if (token != null) {
            /**
             * 存在的话就发起请求去sso拿信息
             */
            CloseableHttpClient httpClient = HttpClients.createDefault();
            HttpGet httpGet = new HttpGet(getDataUrl+&quot;token=&quot;+token);
            CloseableHttpResponse resp = httpClient.execute(httpGet);
            HttpEntity entity = resp.getEntity();
            String userInfo = EntityUtils.toString(entity);
            UserInfo user = JSON.parseObject(userInfo, UserInfo.class);
            /**
             * 两种情况,一种是redis中的key过期了,一种是获得了用户的信息
             * 没有获得告诉用户,会话超时请重新登陆
             * 正常情况下让它通过去该处理的controller
             */
            if (userInfo != null) {
                return true;
            }else {
                writer.println(&quot;&lt;script&gt; alert('会话超时,请重新登陆!');location.href='&quot; + url + &quot;'&lt;/script&gt;&quot;);
                return false;
            }
        }
        return false;
    }
}

</code></pre>
<p><strong>上面需要注意的时情况的划分,然后就是带参数的script语句的拼写</strong></p>
<p><strong>还有就是HttpClient的使用,省时间url直接写上去</strong></p>
<p>获得信息的接口(sso中)</p>
<pre><code class="language-java">  @RequestMapping(&quot;/get_user_by_token&quot;)
    public UserInfo getData(@RequestParam String token){
        return loginService.getData(token);
    }

</code></pre>
<p>service中</p>
<pre><code class="language-java">    /**
     * 本文档用于查找用户信息,从redis中查找,如果没有返回null
     * @param token
     * @return
     */
    @Override
    public UserInfo getData(String token) {
        String user = jedis.get(token);
        UserInfo userInfo = JSON.parseObject(user, UserInfo.class);
        if(userInfo != null){
            return userInfo;
        }
        return null;
    }

</code></pre>
<p>所有的处理结束后</p>
<p>zhengque放行,不zhengque就返回就登陆界面</p>
<p>zhengque后的简单处理</p>
<pre><code class="language-java">@Controller
public class OrderController {

    @RequestMapping(&quot;/order/all&quot;)
    public String toOrder(){
        return &quot;order&quot;;
    }

}


</code></pre>
<p>前端展示xiaog</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;订单页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;pre&gt;
         1.香蕉50斤
         2.苹果50斤
         3.三只松鼠50包
         4.提子50斤
         5.瓜子50斤
            共计250
    &lt;/pre&gt;
&lt;/body&gt;
&lt;/html

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud]]></title>
        <id>https://yihuaikun.github.io/post/springcloud</id>
        <link href="https://yihuaikun.github.io/post/springcloud">
        </link>
        <updated>2019-09-02T14:41:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springcloud之netflix">springcloud之Netflix</h1>
<h2 id="netflix体系简介">Netflix体系简介</h2>
<p>Netflix这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了</p>
<h3 id="核心成员">核心成员</h3>
<h4 id="netflix-eureka">Netflix Eureka</h4>
<p>服务中心，云端服务发现，一个基于  REST  的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。</p>
<h4 id="netflix-ribbon">Netflix Ribbon</h4>
<p>Ribbon是一个客户端负载均衡组件，帮我们实现后端服务节点动态扩容，而不影响调用方。</p>
<h4 id="netflix-hystrix">Netflix Hystrix</h4>
<p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。</p>
<h4 id="netflix-zuul">Netflix Zuul</h4>
<p>Zuul  是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web  网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。</p>
<h4 id="netflix-archaius">Netflix Archaius</h4>
<p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置，   原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p>
<h1 id="eureka和ribbon">Eureka和Ribbon</h1>
<h3 id="单机模式的eureka和ribbon">单机模式的Eureka和Ribbon</h3>
<h4 id="前置工作">前置工作</h4>
<h5 id="1首先是依赖的搭配使用">1.首先是依赖的搭配使用</h5>
<p>详细介绍参见<a href="https://spring.io/projects/spring-cloud">Springcloud依赖版本搭配配置参见</a></p>
<h5 id="2然后再公用模块加依赖">2.然后再公用模块加依赖</h5>
<pre><code class="language-xml">  &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;springboot.version&gt;2.1.6.RELEASE&lt;/springboot.version&gt;
        &lt;springcloud.version&gt;Greenwich.SR2&lt;/springcloud.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.10&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                &lt;!-- 注意：SpringCloud最新的Greenwich版本是基于SpringBoot2.1.x(Greenwich)版本构建的
                    所以这里不支持SpringBoot2.2.x版本
                    具体SpringBoot与SpringCloud版本对应关系参见：https://spring.io/projects/spring-cloud页面最下方的Release Trains
                 --&gt;
                &lt;!--&lt;version&gt;2.2.1.RELEASE&lt;/version&gt;--&gt;
                &lt;version&gt;${springboot.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${springcloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<h3 id="然后创建euraka-server模块">然后创建Euraka-server模块</h3>
<h4 id="1创建项目启动类">1.创建项目启动类</h4>
<pre><code class="language-java">@SpringBootApplication
//这是开启Eureka的注解
@EnableEurekaServer
public class EurekaApplication {
    public static void main(String[] args) throws IOException {
        SpringApplication.run(EurekaApplication.class,args);
    }
}

</code></pre>
<p>需要注意的是,这两个注解一个是统用的,一个是专用的.</p>
<pre><code class="language-java">@EnableDiscoveryClient
@EnableEurekaServer
</code></pre>
<h4 id="2然后配置下yml文件">2.然后配置下yml文件</h4>
<pre><code class="language-yml">server:
  port: 8761

spring:
  application:
    name: eureka-server
eureka:
  instance:
    prefer-ip-address: true
    hostname: localhost
  client:
 # 这个是要不要注册当前的服务注册到eureka中
    register-with-eureka: false
 # 是否从eureka中拉取服务表,即当前服务取注册中心拉取服务   
    fetch-registry: false
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nmBlNO8h-1576064827399)(D:\总结\springcloud\eureks名字.png)]</p>
<h4 id="3启动项目访问eureka日志中的地址出现管理界面">3.启动项目访问Eureka日志中的地址出现管理界面</h4>
<h3 id="创建服务提供者">创建服务提供者</h3>
<h4 id="1创建模块启动类">1.创建模块启动类</h4>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
public class EurekaProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaProviderApplication.class,args);
    }
}

</code></pre>
<h4 id="2配置yml文件">2.配置yml文件</h4>
<pre><code class="language-yml">spring:
  application:
    name: eureka-provider

eureka:
#  这个是客户端的配置
  client:
#    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
#    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: false
    service-url:
#      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
#      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
#      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
#    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
server:
  port: 8082
</code></pre>
<h4 id="3启动模块查看eureka控制home实例">3.启动模块,查看eureka控制home实例</h4>
<h3 id="创建consumer模块">创建consumer模块</h3>
<h4 id="1创建模块启动类-2">1.创建模块启动类</h4>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
public class EurekaConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaConsumerApplication.class,args);
    }
}
</code></pre>
<h4 id="2配置yml文件-2">2.配置yml文件</h4>
<pre><code class="language-yml">server:
  port: 8081

spring:
  application:
    name: eureka-consumer

eureka:
  client:
#    这个是要把服务注册到eureka-server的地址
    service-url: http://${eureka.instance.hostname}:8761/eureka/
#      这个是是否把自己的服务注册到注册中心
    register-with-eureka: true
#    这个是启动时是否拉取服务列表
    fetch-registry: false
  instance:
    hostname: localhost
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
#     在某些情况下，Eureka优先使用IP地址而不是主机名
#    。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    prefer-ip-address: true

</code></pre>
<h4 id="3启动模块查看服务是否注册成功">3.启动模块查看服务是否注册成功.</h4>
<h4 id="4访问localhost8081看服务有问题否">4.访问localhost:8081,看服务有问题否</h4>
<h2 id="出现的问题总结">出现的问题总结:</h2>
<h3 id="1ribbon的理解">1.Ribbon的理解</h3>
<p>​		**ribbon:**是在客户端的负载均衡,也就是说ribbon的负载均衡不在服务端,而是在客户端,这样它启动后就是先拉取服务,放在缓存中,,第二次用的就是缓存中的服务列表,然后即使服务器挂了,本地还有缓存中的服务列表,短暂的也不会影响客户端的使用</p>
<p>​		这样上面的配置就有问题:fetch-registry: false:表示不拉取服务,这样就会访问localhost:8081出现500错误,错误信息是没有instances可用,所以把fetch-registry: true即可则会正常访问</p>
<h1 id="eureka集群的搭建">Eureka集群的搭建</h1>
<p>模块的启动类:注意启动不同的节点要改变生产环境</p>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaCloudApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaCloudApplication.class,args);
    }
}

</code></pre>
<p>主要的配置文件如下:</p>
<p>这样节能直接启动:</p>
<p>​     <strong>注意:</strong> 1.启动不同的节点要改变生产环境</p>
<p>​				2.注意节点启动时会报错,因为还没启动完,最后一个启动不会报错,因为他们之间会互相拉取数据.</p>
<pre><code class="language-yml">spring:
  application:
    name:eureka-cloud-server
  profiles:
    active:

#eureka集群的搭建
eureka:
  client:
#    首先这两个要打开,一个是把当前服务注册到注册中心,一个是拉取其他注册中心的服务
#    高可用
    fetch-registry: true
    register-with-eureka: true
  instance:
    prefer-ip-address: true

---

spring:
  profiles: dev

eureka:
  client:
    service-url:
      defaultZone: http://ip2:port/eureka/,http://ip3:port/eureka/
  instance:
  instance:
    hostname: 主机的ip或主机名

---
spring:
  profiles: node1

eureka:
  client:
    service-url: 
      defaultZone: http://ip1:port/eureka/,http://ip3:port/eureka/
  instance:
    hostname: 主机的ip或主机名
---
spring:
  profiles: node2

eureka:
  client:
    service-url:
      defaultZone: http://ip1:port/eureka/,http://ip2:port/eureka/
  instance:
    hostname: 主机的ip或主机名
</code></pre>
<h1 id="spring-cloud">Spring-Cloud</h1>
<h2 id="netflix-feign组件">netflix---Feign(组件)</h2>
<h3 id="使用底层封装了httpclient">使用:底层封装了HttpClient</h3>
<h4 id="1添加依赖">1.添加依赖</h4>
<pre><code class="language-xml">      &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;
            &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

</code></pre>
<h4 id="2模块启动类">2.模块启动类</h4>
<pre><code class="language-java">@SpringBootApplication
//@EnableEurekaClient
@EnableFeignClients
public class EurekaFeignConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaFeignConsumerApplication.class,args);
    }
}

</code></pre>
<h4 id="3service层的使用">3.service层的使用</h4>
<pre><code class="language-java">@FeignClient(&quot;eureka-provider:8082&quot;)
@Service
public interface CalcService {
    @GetMapping(&quot;/calc/add/{num1}/{num2}&quot;)
    public ResponseInfo add(@PathVariable(&quot;num1&quot;) int num1, @PathVariable(&quot;num2&quot;) int num2);
}
</code></pre>
<p>4.controller层</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/calc&quot;)
@Slf4j
public class CalcController {


    @Autowired
    private CalcService calcService;

    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {

        System.out.println(num1+ &quot;    &quot; + num2);
        // 以前使用SpringMVC方式，直接通过IP+端口号来调用服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://localhost:8081/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        // 引入Ribbon后，通过微服务ID访问远程服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://eureka-provider:8082/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        ResponseInfo info = calcService.add(num1, num2);
//        ResponseInfo info = entity.getBody();
        Map data = (Map) info.getData();
        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);

        return &quot;index&quot;;
    }
}

</code></pre>
<p>4.yml的配置</p>
<pre><code class="language-yml">spring:
  application:
    name: eureka-feign-consumer

eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
server:
  port: 8088
  
feign:
  client:
    config:
      #      calc-service-provider:  这一级可以写具体的微服务名称或者default，default代表全局配置，影响所有微服务的调用
      default:
        connectTimeout: 1000
        readTimeout: 2000  
</code></pre>
<h4 id="5提供者和eureka服务的创建">5.提供者和Eureka服务的创建</h4>
<h1 id="spring-cloud-hystrix组件">Spring-Cloud---hystrix(组件)</h1>
<p><strong>两种方式分别是:hystrix和riboon的整合使用;hystrix和feign整合使用</strong></p>
<h2 id="hystrix熔断器和ribbon的整合使用">Hystrix(熔断器)和Ribbon的整合使用</h2>
<p>​		Hystrix和ribbon的使用主要是hystrix和ReatTemplate的使用.</p>
<p>什么是hystrix?</p>
<blockquote>
<p>在分布式环境中，许多服务依赖项中的一些不可避免地会失败。<br>
Hystrix是一个库，可通过添加延迟容错和容错逻辑来帮助您控制这些分布式服务之间的交互。<br>
Hystrix通过隔离服务之间的访问点，阻止它们之间的级联故障以及提供后备选项来实现这一目标，这些都可以提高系统的整体恢复能力</p>
</blockquote>
<blockquote>
<p>通俗的说Hystrix是Netflix公司开源的一个用于服务调用的断路器组件，给我们提供了包括服务熔断、降级、超时、资源隔离在内的完整解决方案。</p>
</blockquote>
<h2 id="具体使用">具体使用</h2>
<h3 id="1导入用到的依赖">1.导入用到的依赖</h3>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
            &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2启动类开启hystrix熔断">2.启动类开启Hystrix熔断</h3>
<pre><code class="language-java">@SpringBootApplication
@EnableCircuitBreaker //开启熔断
@EnableEurekaClient
public class HystrixRestTemplateApplication {
    @LoadBalanced //tibbon的使用,主要用来请求远程服务和负载均衡使用
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
    public static void main(String[] args) {
        SpringApplication.run(HystrixRestTemplateApplication.class,args);
    }
}

</code></pre>
<h3 id="3web控制层的使用">3.web控制层的使用</h3>
<pre><code class="language-java">/**
 * 计算器
 */
@Controller
@RequestMapping(&quot;/calc&quot;)
@Slf4j
public class CalcController {
    @Autowired
    private RestTemplate restTemplate;
    /**
     * 下面是熔断的使用
     * @param num1
     * @param num2
     * @param model
     * @return
     */
    @HystrixCommand(
            /**
             * 这是熔断点的定义
            */
            fallbackMethod = &quot;addFallback&quot;,
            /**
             * commandKey用于在Properties文件中配置此Command的参数，也可以直接用注解在这里配置参数
            */
            commandKey = &quot;calc_add_command&quot;
    )
    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {

        System.out.println(num1+ &quot;    &quot; + num2);
        // 以前使用SpringMVC方式，直接通过IP+端口号来调用服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://localhost:8081/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        // 引入Ribbon后，通过微服务ID访问远程服务
        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://eureka-provider:8082/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        ResponseInfo info = entity.getBody();
        Map data = (Map) info.getData();

        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        return &quot;index&quot;;
    }
    /**
     * 熔断方法,当服务发生熔断是调用此方法
     * @param num1
     * @param num2
     * @param model
     * @return
     */
    public String addFallback(@RequestParam int num1, @RequestParam int num2, Model model){
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        model.addAttribute(&quot;result&quot;, &quot;-1&quot;);
        return &quot;index&quot;;
    }
}
</code></pre>
<p><strong>注意</strong>:这里的 @HystrixCommand中的参数commandkey的使用是,用于在Properties文件中配置此Command的参数，也可以直接用注解在这里配置参数.</p>
<h3 id="4最重要的yml中的配置">4.最重要的yml中的配置</h3>
<pre><code class="language-yml">spring:
  application:
    name: eureka-consumer-rest_template-hystrix
    
eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    # hystrix中的核心配置
hystrix:
  command:
    calc_add_command:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
      circuitBreaker:
        requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
        sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
        errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
      metrics:
        rollingStats:
          timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s
server:
  port: 8099
</code></pre>
<h3 id="5启动项目测试">5.启动项目测试</h3>
<h2 id="hystrix和feign的整合使用">Hystrix和Feign的整合使用</h2>
<h3 id="1导入依赖">1.导入依赖</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="2web控制层">2.web控制层</h3>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/calc&quot;)
@Slf4j
public class CalcController {
    @Autowired
    private CalcService calcService;

    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {
        System.out.println(num1+ &quot;    &quot; + num2);
        // 以前使用SpringMVC方式，直接通过IP+端口号来调用服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://localhost:8081/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        // 引入Ribbon后，通过微服务ID访问远程服务
//        ResponseEntity&lt;ResponseInfo&gt; entity = restTemplate.getForEntity(&quot;http://eureka-provider:8082/calc/add/&quot;+num1+&quot;/&quot;+num2, ResponseInfo.class);
        ResponseInfo info = calcService.add(num1, num2);
//        ResponseInfo info = entity.getBody();
        Map data = (Map) info.getData();
        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        return &quot;index&quot;;
    }
}
</code></pre>
<h3 id="3service层">3.service层</h3>
<pre><code class="language-java">@FeignClient(value = &quot;eureka-provider:8082&quot;,fallback = FallbackClient.class)
@Service
public interface CalcService {
    @GetMapping(&quot;/calc/add/{num1}/{num2}&quot;)
    public ResponseInfo add(@PathVariable(&quot;num1&quot;) int num1,@PathVariable(&quot;num2&quot;) int num2);
}
</code></pre>
<p>需要注意的是fallback熔断方法的实现要和实现的接口的请求地址分开,因为实现接口会默认继承GetMappig 的请求地址,防止出现暧昧关系</p>
<p>熔断方法</p>
<pre><code class="language-java">@Component
@RequestMapping(&quot;/fallback&quot;)
public class FallbackClient implements CalcService {
    @Override
    public ResponseInfo add(int num1, int num2) {
        Map data = new HashMap();
        data.put(&quot;num1&quot;, num1);
        data.put(&quot;num2&quot;, num2);
        data.put(&quot;result&quot;, -1);
        ResponseInfo responseInfo = new ResponseInfo(203,  &quot;降级结果&quot;, data);
        return responseInfo;
    }
}
</code></pre>
<h3 id="4配置文件">4.配置文件</h3>
<pre><code class="language-yml">spring:
  application:
    name: eureka-consumer-feign-hystrix


eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}

hystrix:
  command:
#    default:  # 设置全局熔断参数
    CalcService#add(int,int): #设置某个feign client的熔断参数
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
        circuitBreaker:
          requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
          sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
          errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
        metrics:
          rollingStats:
            timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s

feign:
  client:
    config:
      #      calc-service-provider:  这一级可以写具体的微服务名称或者default，default代表全局配置，影响所有微服务的调用
      default:
        connectTimeout: 1000
        readTimeout: 2000
  hystrix:
    enabled: true
server:
  port: 8100

</code></pre>
<h3 id="5需要注意的问题">5.需要注意的问题</h3>
<p>​		在feign中默认的hystrix是默认关闭的,如果不打开的话,会出现找不到fallback的错误,错误类型是500.</p>
<h1 id="监控工具">监控工具</h1>
<h2 id="springboot-actuator">SpringBoot Actuator</h2>
<p>SpringBoot Actuactor是SpringBoot提供的一个监控工具，通过他我们可以看到应用运行工程中的很多有用的信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Enabled by default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">auditevents</td>
<td style="text-align:left">Exposes audit events information for the current application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">beans</td>
<td style="text-align:left">Displays a complete list of all the Spring beans in your application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">conditions</td>
<td style="text-align:left">Shows the conditions that were evaluated on configuration and auto-configuration classes and the reasons why they did or did not match.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">configprops</td>
<td style="text-align:left">Displays a collated list of all <code class="literal">@ConfigurationProperties</code>.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">env</td>
<td style="text-align:left">Exposes properties from Spring’s <code class="literal">ConfigurableEnvironment</code>.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">flyway</td>
<td style="text-align:left">Shows any Flyway database migrations that have been applied.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">health</td>
<td style="text-align:left">Shows application health information.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">httptrace</td>
<td style="text-align:left">Displays HTTP trace information (by default, the last 100 HTTP request-response exchanges).</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">info</td>
<td style="text-align:left">Displays arbitrary application info.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">loggers</td>
<td style="text-align:left">Shows and modifies the configuration of loggers in the application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">liquibase</td>
<td style="text-align:left">Shows any Liquibase database migrations that have been applied.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">metrics</td>
<td style="text-align:left">Shows ‘metrics’ information for the current application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">mappings</td>
<td style="text-align:left">Displays a collated list of all <code class="literal">@RequestMapping paths</code>.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">scheduledtasks</td>
<td style="text-align:left">Displays the scheduled tasks in your application.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">sessions</td>
<td style="text-align:left">Allows retrieval and deletion of user sessions from a Spring Session-backed session store. Not available when using Spring Session’s support for reactive web applications.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">shutdown</td>
<td style="text-align:left">Lets the application be gracefully shutdown.</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">threaddump</td>
<td style="text-align:left">Performs a thread dump.</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<p><font color="orange">如果应用是一个Web应用（指引入了SpringMVC、Spring WebFlux或者Jersey），就可以用下面这些监控端点</font></p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Enabled by default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">heapdump</td>
<td style="text-align:left">Returns an hprof heap dump file.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">jolokia</td>
<td style="text-align:left">Exposes JMX beans over HTTP (when Jolokia is on the classpath, not available for WebFlux).</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">logfile</td>
<td style="text-align:left">Returns the contents of the logfile (if logging.file or logging.path properties have been set). Supports the use of the HTTP Range header to retrieve part of the log file’s content.</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">prometheus</td>
<td style="text-align:left">Exposes metrics in a format that can be scraped by a Prometheus server.</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<p>除了上面列出来的，其他第三方模块还会提供一些特有的监控端点，如zuul提供的/routes</p>
<h1 id="springcloud-zuul路由网关">Springcloud-zuul(路由网关)</h1>
<h2 id="zuul介绍">Zuul介绍</h2>
<blockquote>
<p>Zuul是Netflx开源的微服务网关。可以和Eureka、Ribbon、Hystrix配合使用，一个主要的功能就是可以将后端众多的微服务屏蔽、整合，对前端提供一套统一的服务(有点像是后端的Facade)。</p>
</blockquote>
<p>Zuul提供了以下几项支持：</p>
<ul>
<li>认证安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</li>
<li>监控</li>
<li>动态路由: 动态将请求路由到不同后端集群</li>
<li>压力测试: 逐渐增加指向集群的流量，以了解性能</li>
<li>金丝雀测试: 灰度发布</li>
<li>流量控制: 为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>服务迁移</li>
<li>静态资源响应处理: 边缘位置进行响应，避免转发到内部集群</li>
</ul>
<h2 id="zuul用的地方是">zuul用的地方是</h2>
<p>一般用在服务的提供者</p>
<h3 id="1加依赖">1.加依赖</h3>
<pre><code class="language-xml">     &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="2创建springcloud-zuul">2.创建springcloud-zuul</h3>
<pre><code class="language-java">@SpringBootApplication
@EnableZuulProxy
@EnableEurekaClient
public class ZuulApplication {
    public static void main(String[] args) {
        SpringApplication.run(ZuulApplication.class, args);
    }

}
</code></pre>
<h3 id="3配置">3.配置</h3>
<pre><code class="language-yml">server:
  port: 10003
spring:
  application:
    name: zuul-server

eureka:
  #  这个是客户端的配置
  client:
    #    这个是是否把当前服务注册到注册中心
    register-with-eureka: true
    #    这个是是否要拉取服务,一般在集群中用到
    fetch-registry: true
    service-url:
      #      这个是服务要提交服务所到的地址,同时也是eureka在浏览器的访问地址,一般是和eureka的server保持一致,
      #      表明提交服务到的地址是eureka-server的地址
      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
  #      这个是实例,即你的服务的相关配置
  instance:
    hostname: localhost
    prefer-ip-address: true
    #    这个是实例在注册中心的id
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
zuul:
  routes:
    # 这种方式配置路由规则：前面的key是微服务名称，后面是匹配路径
    #    calc-service-provider: /calcApi/**
    # 这种方式配置路由规则：第一级的key可以随便取（路由名称），下面可以配置更多key、value（相比上面一种配置更强大）
    calc-proxy:
      serviceId: eureka-provider # 有效的微服务名称
      path: /calc/**  # 访问路径
      strip-prefix: false # 是否在网关层面消耗掉指定服务的路由规则前缀
    #    taotao-rest-proxy:
    #      serviceId: taotao-rest
    #      path: /rest/**

</code></pre>
<p><strong>注意上上面的strip-prefix: 值的用法</strong></p>
<p>1.上面的strip-prefix: false设置false代表你访问**localhost:10003/calc/****会跳转到对应的服务是eureka-provider,然后到注册中心找到对应的服务,localhost:8082/calc/add/55/66</p>
<pre><code>2.   上面的strip-prefix: false设置false代表你访问localhost:**10003/calc/calc/****会跳转到对应的服务是eureka-provider,然后到注册中心找到对应的服务,localhost:8082/calc/add/55/66
</code></pre>
<h3 id="代理传统的服务">代理传统的服务</h3>
<p>配置如下</p>
<pre><code class="language-yml">server:
  port: 9100
spring:
  application:
    name: zuul-server

eureka:
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8761
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: node1.john.com

management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;

zuul:
  routes:
    # 这种方式配置路由规则：前面的key是微服务名称，后面是匹配路径
#    calc-service-provider: /calcApi/**
    # 这种方式配置路由规则：第一级的key可以随便取（路由名称），下面可以配置更多key、value（相比上面一种配置更强大）
    calc-proxy:
      serviceId: calc-service-provider # 有效的微服务名称
      path: /calc/**  # 访问路径
      strip-prefix: false # 是否在网关层面消耗掉指定服务的路由规则前缀
      #代理传统的服务:
#    taotao-rest-proxy:
#      serviceId: taotao-rest
#      path: /rest/**
    taotao-rest-proxy-forward: # 使用forward本地转发(就是将匹配到路由规则的请求，转发到网关本地应用中去处理)
      path: /rest-f/**
      url: forward:/rest
    # 比如浏览器访问：http://localhost:9100/api/rest-f/content/getall/89
    # 会被转发到：http://localhost:9100/rest/content/getall/89


  ignored-services: &quot;*&quot; # 忽略所有未显示配置路由规则的微服务
  prefix: /api
  strip-prefix: true  # 是否在网关层面消耗掉全局前缀


# 使用Zuul代理未接入Eureka的传统服务
taotao-rest:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList #如果不配置ServerList类型为ConfigurationBasedServerList的话就需要禁用ribbon的eureka支持
    ConnectTimeout: 500
    ReadTimeout: 2000
    listOfServers: http://localhost:8081

calc-service-provider:
  ribbon:
    ReadTimeout: 2000
    ConnectTimeout: 500

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Mybatis实现批量插入]]></title>
        <id>https://yihuaikun.github.io/post/mybatis-shi-xian-pi-liang-cha-ru</id>
        <link href="https://yihuaikun.github.io/post/mybatis-shi-xian-pi-liang-cha-ru">
        </link>
        <updated>2019-08-23T15:39:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis实现批量插入">Mybatis实现批量插入</h1>
<p>环境配置</p>
<p>1.依赖</p>
<pre><code class="language-xml"> &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.20&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.10&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>2.application.xml中的配置</p>
<pre><code class="language-yml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
&lt;!--        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;--&gt;
&lt;!--        &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;--&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/studentMapper.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/userMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>2.jdbc.properties</p>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost/day03?characterEncoding=utf-8
jdbc.user=root
jdbc.password=123456
</code></pre>
<p>6.创建数据库student</p>
<h2 id="实现技术mybatis的动态sql">实现技术:Mybatis的动态sql</h2>
<h3 id="第一种是mapperxml中的foreach动态sql语句">第一种是mapper.xml中的foreach动态sql语句</h3>
<p>1.首先创建测试类:Student</p>
<pre><code class="language-java">@Setter
@Getter
@ToString
public class Student {
    private int sId;
    private String sName;
    private String sex;
    private int age;
    private String subject;
    private String phone;

    public Student() {
    }

    public Student(int sId, String sName, String sex, int age, String subject, String phone) {
        this.sId = sId;
        this.sName = sName;
        this.sex = sex;
        this.age = age;
        this.subject = subject;
        this.phone = phone;
    }

    public Student(String sName, String sex, int age, String subject, String phone) {
        this.sName = sName;
        this.sex = sex;
        this.age = age;
        this.subject = subject;
        this.phone = phone;
    }
    public Student(int sId, String sName) {
        this.sId = sId;
        this.sName = sName;
    }
}
</code></pre>
<p>2.然后创建mapper接口</p>
<pre><code class="language-java">public interface StudentMapper {
    int insert(List&lt;Student&gt; studentList);
}
</code></pre>
<p>3.然后配置mapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou.mapper.StudentMapper&quot;&gt;

&lt;!--    &lt;cache/&gt;--&gt;
&lt;!--  这是测试forEach的第一种  --&gt;
    &lt;insert id=&quot;insert&quot; &gt;
        insert into student(s_name,sex,age,subject,phone) values
        &lt;foreach collection=&quot;list&quot; item=&quot;stu&quot; separator=&quot;,&quot; &gt;
           ( #{stu.sName},
            #{stu.sex},
            #{stu.age},
            #{stu.subject},
            #{stu.phone})
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>3.然后测试一下</p>
<pre><code class="language-java">    /**
     *这是测试forEach的第一种方法:
     */
    @Test
    public void testForEacher(){
        String xmlPath= &quot;mybatis-config.xml&quot;;
        try {
            InputStream inputStream = Resources.getResourceAsStream(xmlPath);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //开启自动提交:如果不开启则会看到一级缓存的作用true
            SqlSession sqlSession = sqlSessionFactory.openSession();
            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
            //String sName, String sex, int age, String subject, String phone
            List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();
            Collections.addAll(studentList,
                    new Student(&quot;黄三&quot;,&quot;女&quot;,23,&quot;蓝翔挖掘机&quot;,&quot;11111111111&quot;),
                    new Student(&quot;黄四&quot;,&quot;男&quot;,20,&quot;蓝翔厨师&quot;,&quot;22222222222&quot;),
                    new Student(&quot;黄五&quot;,&quot;女&quot;,25,&quot;电大&quot;,&quot;33333333333&quot;)
                    );
            studentMapper.insert(studentList);
            //没有开启自动提交,就会对缓存进行操作,只有这样才能会提交缓存中的数据到数据库,更新数据.
            sqlSession.commit();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<h3 id="第二种是简单的sql语句逻辑实现foreach">第二种是简单的sql语句,逻辑实现foreach</h3>
<p>1.mapper.xml中</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou.mapper.StudentMapper&quot;&gt;
    &lt;!--  这是forEacher的第二种  --&gt;
    &lt;insert id=&quot;insert2&quot; &gt;
        insert into student(s_name,sex,age,subject,phone) values
             (#{sName},
            #{sex},
            #{age},
            #{subject},
            #{phone})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>2.然后定义mapper接口</p>
<pre><code class="language-java">public interface StudentMapper {
    int insert2(Student student);
}
</code></pre>
<p>3.然后测试</p>
<pre><code class="language-java">    /**
     * 这是forEach的第二种方法,和批处理
     */
    @Test
    public void testForEach2(){
        String xmlPath= &quot;mybatis-config.xml&quot;;
        try {
            InputStream inputStream = Resources.getResourceAsStream(xmlPath);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //开启自动提交:如果不开启则会看到一级缓存的作用true
            //ExecutorType默认是simple一条一执行,还有就是batch使用这个得  sqlSession.flushStatements()才会提交数据

            SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH,true);
            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
            //String sName, String sex, int age, String subject, String phone
            List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();
            Collections.addAll(studentList,
                    new Student(&quot;黄三&quot;,&quot;女&quot;,23,&quot;蓝翔挖掘机&quot;,&quot;11111111111&quot;),
                    new Student(&quot;黄四&quot;,&quot;男&quot;,20,&quot;蓝翔厨师&quot;,&quot;22222222222&quot;),
                    new Student(&quot;黄五&quot;,&quot;女&quot;,25,&quot;电大&quot;,&quot;33333333333&quot;)
            );

//            对缓存的操作之批量插入:
            int count = 0;
            for(Student student : studentList ){
                studentMapper.insert2(student);
                count++;
                if(count % 2 == 0){
                    sqlSession.flushStatements();
                }
            }
//          对剩余得处理:
            if(count % 2 != 0){
               sqlSession.flushStatements();
            }
            //没有开启自动提交,就会对缓存进行操作,只有这样才能会提交缓存中的数据到数据库,更新数据.
            sqlSession.commit();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis总结]]></title>
        <id>https://yihuaikun.github.io/post/mybatis-zong-jie</id>
        <link href="https://yihuaikun.github.io/post/mybatis-zong-jie">
        </link>
        <updated>2019-08-14T04:31:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis框架学习">Mybatis框架学习</h1>
<h2 id="mybatis介绍">Mybatis介绍</h2>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis<br>
避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis<br>
可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old<br>
Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h2 id="mybatis简单使用">Mybatis简单使用</h2>
<h3 id="1初始化sqlsessionfactory对象">1.初始化SqlSessionFactory对象:</h3>
<h4 id="1sqlsessionfactory对象">1.SqlSessionFactory对象:</h4>
<p>需要从核心配置文件中获得,因此我们创建SqlSessionFactory对象时需要先配置一个Mybatis核心配置文件,过程如下:</p>
<p>1&gt;.创建一个模板:建议最好去官网上找模板<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">Mybatis配置模板</a></p>
<p><img src="https://img-blog.csdnimg.cn/20191019172955442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt=""><img src="https://img-blog.csdnimg.cn/20191019173125581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2效果试图和创建mybatis过程">2.效果试图和创建Mybatis过程:</h4>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191019173149492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="3创建后的文件">3.创建后的文件:</h4>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/201910191732101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="2核心配置文件如下">2.核心配置文件如下:</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 引入外部properties文件,路径从类路径的根目录开始 --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;

    &lt;settings&gt;
        &lt;!-- 开启将数据库中下划线连接的字段自动映射为Java的小驼峰命名 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;!-- 定义类型别名，在xxxMapper.xml文件中就可以用别名代替很长的类名 --&gt;
    &lt;typeAliases&gt;
        
            &lt;!-- 单个类配置别名 --&gt;
&lt;!--        &lt;typeAlias type=&quot;com.lanou3g.mybatis.bean.User&quot; alias=&quot;User&quot; /&gt;--&gt;
        
            &lt;!-- 统一配置某个包下所有类的别名, 会使用 Bean 的首字母小写的类名来作为它的别名。 --&gt;
        &lt;package name=&quot;com.lanou3g.mybatis.bean&quot; /&gt;
    &lt;/typeAliases&gt;


    &lt;!-- 配置不同环境的参数 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- 开发环境数据库、事务配置 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 事务管理使用JDBC的事务 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置开发环境数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                &lt;!-- 将所有driver.开头的参数，附加到url属性的值后面上 --&gt;
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 将mapper SQL映射文件包含进来 --&gt;
    &lt;mappers&gt;
        &lt;!-- 将通过XML方式配置的mapper引入进来 --&gt;
        &lt;mapper resource=&quot;mapper/userMapper.xml&quot;/&gt;
        &lt;!-- 将通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;mapper class=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot; /&gt;--&gt;

        &lt;!-- 将com.lanou3g.mybatis.mapper包下所有通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;package name=&quot;com.lanou3g.mybatis.mapper&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="1构建对象">1.构建对象:</h4>
<pre><code class="language-java"> @Test
    public void testXml() throws IOException {
        String xmlPath = &quot;mybatis_config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(xmlPath);
        SqlSessionFactory sessionFactory = new 			                      SqlSessionFactoryBuilder().build(inputStream);
        System.out.println(sessionFactory);
    }
</code></pre>
<h4 id="2创建sqlsession对象">2.创建SqlSession对象</h4>
<p>通过上步的SqlSessionFactory对象的创建可以获取到负责执行sql的SqlSession对象</p>
<pre><code class="language-java">// 3. 获取SqlSession对象，默认事务不自动提交
// SqlSession sqlSession = sqlSessionFactory.openSession();
// 获取一个自动提交事务的sqlSession
SqlSession sqlSession = sqlSessionFactory.openSession();
</code></pre>
<h4 id="3用sqlsession对象从mybatis中获取mapper接口的实现类">3.用SqlSession对象从Mybatis中获取Mapper接口的实现类</h4>
<pre><code class="language-java"> StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
</code></pre>
<h4 id="4编写mapper对象的xml配置文件">4.编写Mapper对象的xml配置文件</h4>
<p>和核心配置文件的步骤一样去官网找文档配置修改之后是这样,这里可以配合Fre Mybatis plugin插件使用效率更高:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
        select * from user
     &lt;/select&gt;

    &lt;insert id=&quot;insertUser&quot;&gt;
      insert into user (username,nick_name,email)
      values (#{username},#{nickName},#{email})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h1 id="深入了解mybatis">深入了解Mybatis</h1>
<h2 id="主要组件">主要组件</h2>
<h3 id="核心配置文件的处理">核心配置文件的处理:</h3>
<p>所谓的核心配置文件,就是mybatis的入口.它里面可以配置mybatis的具体参数、数据源、类型别名、关联映射文件等。</p>
<h4 id="加载mybatis配置文件的路径">加载Mybatis配置文件的路径:</h4>
<pre><code class="language-java"> String configMybatisXmlpath = &quot;mybatis-config.xml&quot;;
</code></pre>
<h4 id="resources">Resources</h4>
<pre><code class="language-java">package org.apache.ibatis.io;
//Resources:所在的包.
	public static InputStream getResourceAsStream(String resource) throws IOException {
        return getResourceAsStream((ClassLoader)null, resource);
    }

	public static InputStream getUrlAsStream(String urlString) throws IOException {
        URL url = new URL(urlString);
        URLConnection conn = url.openConnection();
        return conn.getInputStream();
    }

//上面是底层常用的方法:
//例如:加载加载Mybatis配置文件
InputStream inputStream = Resources.getResourceAsStream(configurationXmlPath);
</code></pre>
<h4 id="sqlsessionfactorybuilser">SqlSessionFactoryBuilser</h4>
<p>主要用来创建SqlSessionFactory接口类对象.</p>
<pre><code class="language-java">//SqlSessionFactoryBuiler所在的包:
package org.apache.ibatis.session;

	public SqlSessionFactory build(Reader reader, String environment) {
        return this.build((Reader)reader, environment, (Properties)null);
    }

	public SqlSessionFactory build(InputStream inputStream) {
        return this.build((InputStream)inputStream, (String)null, (Properties)null);
    }
//上面是SqlSessionFactoryBuilser的部分底层.我们调用build方法来获得下面的SqlSessionFactory接口类对象.
//例如下面:获得SqlSessionFactory接口类对象:development表示xml中的environment的id
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream,&quot;development&quot;);

</code></pre>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p>一个SqlSessionFactory只能连接一个数据库实例，如果需要连接多个数据库，需要构建多个SqlSessionFactory对象。</p>
<p>在构建SqlSesssionFactory时可以指定environment的id，表示使用指定的数据源来构建factory对象</p>
<pre><code class="language-java">	//这个是是否开启自动提交事务:入过不开启自动提交的话可能出现sql语句执行了,页成功了但	
	//是没有插入到数据库例如下面实例:一般我们把参数设置为true,让它自动提交事务,如果没有设置出现下面实例	//	中的错误,在实例1下面由解决方法.注意Query时开不开没关系,最好开启
	SqlSession openSession((boolean autoCommit);
    SqlSession openSession(Connection var1);                        
    //TransactionIsolationLevel是一个枚举类,事务隔离
	// NONE(0),
    //READ_COMMITTED(2),
    //READ_UNCOMMITTED(1),
    //REPEATABLE_READ(4),
    //SERIALIZABLE(8);
    SqlSession openSession(TransactionIsolationLevel level);
	// ExecutorType枚举类
    //SIMPLE,
    //REUSE,
    //BATCH;   最常用的试着个,Mybatis缓冲,下面我们会总结到                
    SqlSession openSession(ExecutorType var1);

    SqlSession openSession(ExecutorType var1, boolean var2);

    SqlSession openSession(ExecutorType var1, TransactionIsolationLevel var2);

    SqlSession openSession(ExecutorType var1, Connection var2);

    Configuration getConfiguration();
</code></pre>
<p>关于Mybatis的TransactionIsolationLevel枚举类的探究,事务隔离级别:</p>
<p>​			隔离级别：一个事务必须与由其他事务进行的资源或数据更改相隔离的程度。隔离级别从允许的并发副作用（例如，脏读或虚拟读取）的角度进行描述。</p>
<pre><code class="language-java">none:
read uncommitted | 1 未提交读
read committed | 2 已提交读
repeatable read | 4 可重复读
serializable | 8 可序列化
</code></pre>
<p>实例1:</p>
<pre><code class="language-java">    @Test
    public void testPaperGirl() {
        String configurationXmlPath = &quot;mybatis-config.xml&quot;;
        try {
            InputStream inputStream = 					            Resources.getResourceAsStream(configurationXmlPath);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //注意这里要开启事务:坑
            SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
            KingMapper mapper = sqlSession.getMapper(KingMapper.class);
            List&lt;Girl&gt; girlList = new ArrayList&lt;&gt;();
            Collections.addAll(girlList, new Girl(&quot;木兰&quot;, 2), new Girl(&quot;伽罗&quot;, 2));
            int count = 0;
            List&lt;BatchResult&gt; batchResults = null;
            for(Girl girl : girlList){
                mapper.insertPaperGir(girl);
                count ++ ;
                if(count % 2 == 0){
                    batchResults = sqlSession.flushStatements();
                    count = 0 ;
                }
            }
            for(BatchResult batchResult : batchResults){
                int[] updateCounts = batchResult.getUpdateCounts();
                for(int updateCount : updateCounts){
                    System.out.println(updateCount);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>结果如下:<br>
<img src="https://img-blog.csdnimg.cn/20191019173358929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>但是数据库中并没有插入:</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191019173413717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>解决办法有两种</p>
<pre><code class="language-java">//解决方法一:
SqlSession openSession(true);
//解决方法二
    @Test
    public void testPaperGirl() {
        String configurationXmlPath = &quot;mybatis-config.xml&quot;;
        try {
            InputStream inputStream = Resources.getResourceAsStream(configurationXmlPath);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //注意这里要开启事务:坑
            SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
            KingMapper mapper = sqlSession.getMapper(KingMapper.class);
            List&lt;Girl&gt; girlList = new ArrayList&lt;&gt;();
            Collections.addAll(girlList, new Girl(&quot;木兰&quot;, 2), new Girl(&quot;伽罗&quot;, 2));
            int count = 0;
            List&lt;BatchResult&gt; batchResults = null;
            for(Girl girl : girlList){
                mapper.insertPaperGir(girl);
                count ++ ;
                if(count % 2 == 0){
                    batchResults = sqlSession.flushStatements();
                    count = 0 ;
                }
            }
            for(BatchResult batchResult : batchResults){
                int[] updateCounts = batchResult.getUpdateCounts();
                for(int updateCount : updateCounts){
                    System.out.println(updateCount);
                }
            }
            //在这里加事务提交:
            sqlSession.commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

</code></pre>
<p>解决后结果:</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191019173449651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="sqlsession">SqlSession</h4>
<p>一个SqlSession对象代表一次到数据的会话，该对象有一下功能：</p>
<ul>
<li>获取Mapper实现类</li>
<li>管理事务操作</li>
<li>注意： SqlSession对象是非线程安全的，在多线程环境下，建议不要作为类的实例属性来用。</li>
</ul>
<h4 id="mapper接口类">Mapper接口类:</h4>
<h4 id="mapper">Mapper</h4>
<ul>
<li>
<p>Mapper接口类</p>
<p>定义了增删盖查的方法。注意，必须是接口类型，而且方法只需要定义就可以了。</p>
</li>
<li>
<p>Mapper配置文件</p>
<p>Mapper配置文件中就是负责实现接口中的方法，它定义了具体要执行什么SQL语句，如何映射结果集。</p>
<ul>
<li>配置文件中select、delete、update、insert标签的id必须是对应接口中的方法名。</li>
<li>mapper文件的namespace属性需要对应Mapper接口的完全类型限定名。</li>
</ul>
</li>
</ul>
<h1 id="深入mybatis核心配置文件">深入Mybatis核心配置文件</h1>
<h2 id="深入mybatis映射配置文件">深入Mybatis映射配置文件</h2>
<h3 id="crud语句定义">CRUD语句定义</h3>
<p>接口中的源码</p>
<pre><code class="language-java">public interface KingMapper {
    List&lt;King&gt; findKingById(int id);
    int insertGirl(List&lt;Girl&gt; girlList);
    int insertPaperGir(Girl girl);
}

</code></pre>
<p>xml中的配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou.mapper.KingMapper&quot;&gt;

    &lt;resultMap id=&quot;kingMap&quot; type=&quot;com.lanou.bean.King&quot;&gt;
        &lt;id column=&quot;k_id&quot; property=&quot;kId&quot;/&gt;
        &lt;result column=&quot;k_name&quot; property=&quot;kName&quot;/&gt;
        &lt;association property=&quot;queen&quot; javaType=&quot;com.lanou.bean.Queen&quot; resultMap=&quot;queenMap&quot;/&gt;
        &lt;collection property=&quot;girls&quot; ofType=&quot;com.lanou.bean.Girl&quot; resultMap=&quot;girlMap&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;resultMap id=&quot;girlMap&quot; type=&quot;com.lanou.bean.Girl&quot;&gt;
        &lt;id property=&quot;gId&quot; column=&quot;g_id&quot;/&gt;
        &lt;result property=&quot;kId&quot; column=&quot;k_id&quot;/&gt;
        &lt;result property=&quot;gName&quot; column=&quot;g_name&quot;/&gt;

    &lt;/resultMap&gt;

    &lt;resultMap id=&quot;queenMap&quot; type=&quot;com.lanou.bean.Queen&quot;&gt;
        &lt;id column=&quot;q_id&quot; property=&quot;qId&quot;/&gt;
        &lt;result column=&quot;k_id&quot; property=&quot;kId&quot;/&gt;
        &lt;result column=&quot;q_name&quot; property=&quot;qName&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;insert id=&quot;insertGirl&quot;&gt;
        insert into girl (g_name,k_id) values
        &lt;foreach collection=&quot;list&quot; item=&quot;girl&quot; separator=&quot;,&quot;&gt;
            (#{girl.gName},#{girl.kId})
        &lt;/foreach&gt;
    &lt;/insert&gt;
    &lt;insert id=&quot;insertPaperGir&quot;&gt;
      insert into girl (g_name,k_id) values(#{gName},#{kId})
    &lt;/insert&gt;

    &lt;select id=&quot;findKingById&quot; resultMap=&quot;kingMap&quot;&gt;

        select
         king.k_id k_id,
         k_name,
         q_id,
         q_name,
         g_id,
         g_name
        from king
        left join girl
        on king.k_id = girl.k_id
        left join queen
        on queen.k_id = king.k_id
        where king.k_id = #{id};
    &lt;/select&gt;
&lt;/mapper
</code></pre>
<h4 id="插入语句">插入语句</h4>
<h5 id="普通插入语句">普通插入语句</h5>
<p>接口</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml中的配置</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h4 id="如何返回数据库自增的id">如何返回数据库自增的ID</h4>
<h5 id="java源代码之接口中">java源代码之接口中</h5>
<pre><code class="language-java">public interface GirlMapper {
    int insertGirl(Girl girl);
}
</code></pre>
<h5 id="xml中">xml中</h5>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
ps:只对update和insert语句使用
     --&gt;
 &lt;insert id=&quot;insertGirl&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;gId&quot; &gt;
        insert into girl (g_name,k_id)
        values(#{gName},#{kId})
    &lt;/insert&gt;
</code></pre>
<h5 id="测试">测试</h5>
<pre><code class="language-java">@Test
    public void testGirl(){
        String configMybatisXmlpath = &quot;mybatis-config.xml&quot;;
        try {
            InputStream resourceAsStream = Resources.getResourceAsStream(configMybatisXmlpath);
            SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
            SqlSession sqlSession = sessionFactory.openSession(true);
            GirlMapper girlMapper = sqlSession.getMapper(GirlMapper.class);
            Girl girl = new Girl(&quot;香蛋&quot;,1);
            int i = girlMapper.insertGirl(girl);
            System.out.println(girl.getGId());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<h5 id="结果">结果</h5>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191019173555319.png" alt="在这里插入图片描述"></figure>
<h5 id="ps">ps:</h5>
<p>​	keyColumn=&quot;&quot;:（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。</p>
<p>​	keyProperty=&quot;&quot; :给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上:</p>
<p>​		useGeneratedKeys: 指定需要获取数据库自增的id<br>
keyProperty: 指定自增地段的名称</p>
<p>只对update和insert语句使用</p>
<h4 id="删除语句">删除语句</h4>
<p>接口中</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>xml中的配置:</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h4 id="更新语句">更新语句</h4>
<p>接口中:</p>
<pre><code class="language-java">void updateUser(User user);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot;&gt;
    update user set password = #{password} where id = #{id}
&lt;/update&gt;
</code></pre>
<h4 id="ps-2">ps:</h4>
<p>插入和更新删除需要:</p>
<pre><code class="language-java">    SqlSession sqlSession = sessionFactory.openSession(true);
</code></pre>
<h3 id="接口中的参数如果传递到sql中">接口中的参数如果传递到SQL中</h3>
<h4 id="简单类型参数">简单类型参数</h4>
<p>接口中</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>xml配置</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h4 id="引用类型参数">引用类型参数</h4>
<p>接口中</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<pre><code class="language-xml">&lt;!--这里注意取参数直接#+实体类字段名--&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h4 id="当接口中参数和xml配置取值时名称不一样时">当接口中参数和XML配置取值时名称不一样时</h4>
<p>ps:现在Mybatis版本中的不存在这个问题</p>
<p>在接口中的参数前加注解</p>
<pre><code class="language-java">User queryUserById(@Param(&quot;id&quot;) Integer xxxxxxxId);
</code></pre>
<p>在XML中取值时用注解指定的名称</p>
<pre><code class="language-xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<p>例如:</p>
<p>接口中的java代码:</p>
<pre><code class="language-java">public interface GirlMapper {
    Girl queryGirl(Integer sid);
}
</code></pre>
<p>xml中的配置:</p>
<pre><code class="language-xml">    &lt;select id=&quot;queryGirl&quot; resultType=&quot;com.lanou.bean.Girl&quot;&gt;
        select * from girl where g_id = #{gId}
    &lt;/select&gt;

</code></pre>
<p>运行的结果:<br>
<img src="https://img-blog.csdnimg.cn/20191019173831808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="与的区别">#{}与${}的区别</h4>
<ul>
<li>它俩都可以获取接口调用中传递过来的参数</li>
<li>#{}会将参数作为占位符，使用预编译语句(PreparedStatement)执行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">会</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi></mrow><annotation encoding="application/x-tex">{}会直接用实际参数替换</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span></span></span></span>{}， 参数可以作为SQL的一部分。</li>
</ul>
<p>接口中的配置:</p>
<pre><code class="language-java">public interface GirlMapper {
    Girl queryGirl(Integer sid);
}
</code></pre>
<p>xml配置:</p>
<pre><code class="language-xml">    &lt;select id=&quot;queryGirl&quot; resultType=&quot;com.lanou.bean.Girl&quot;&gt;
        select * from girl where g_id = #{gId}
    &lt;/select&gt;
</code></pre>
<p>#的运行结果:<br>
<img src="https://img-blog.csdnimg.cn/20191019173856777.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191019173909890.png" alt="在这里插入图片描述"></p>
<h4 id="结果集如何映射">结果集如何映射</h4>
<h5 id="resulttype方式">ResultType方式</h5>
<p>​	ResultType方式适用于数据库结果集可以直接映射成一个Java类的情况</p>
<h5 id="resultmap方式">ResultMap方式</h5>
<p>​	ResultMap方式适用于复杂的结果集映射，比如数据库返回的结果集中的列名和JavaBean无法一一对应，或者对象间存在一对一、一对多关联映射时。</p>
<h6 id="解决数据库列名与java类中属性名不一致的映射问题">解决数据库列名与Java类中属性名不一致的映射问题</h6>
<h6 id="解决一对一映射查询问题">解决一对一映射查询问题</h6>
<h6 id="解决一对多映射查询问题">解决一对多映射查询问题</h6>
<p>下面是例子:</p>
<pre><code class="language-java">package com.lanou.bean;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Setter
@Getter
@ToString
public class Girl {
    private int gId;
    private int kId;
    private String gName;
    public Girl(){

    }
    public Girl(String gName ,int kId) {
        this.gName = gName;
        this.kId = kId;

    }
}
</code></pre>
<pre><code class="language-java">package com.lanou.bean;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@Setter
@Getter
@ToString
public class King {
    private int kId;
    private String kName;
    private Queen queen;
    private List&lt;Girl&gt; girls;
}

</code></pre>
<pre><code class="language-java">package com.lanou.bean;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
public class Queen {
    private int qId;
    private int kId;
    private String qName;
}

</code></pre>
<p>接口中</p>
<pre><code class="language-java">package com.lanou.mapper;

import com.lanou.bean.Girl;
import com.lanou.bean.King;

import java.util.List;

public interface KingMapper {
    List&lt;King&gt; findKingById(int id);
    int insertGirl(List&lt;Girl&gt; girlList);
    int insertPaperGir(Girl girl);
}

</code></pre>
<p>xml中的配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou.mapper.KingMapper&quot;&gt;

    &lt;resultMap id=&quot;kingMap&quot; type=&quot;com.lanou.bean.King&quot;&gt;
        &lt;id column=&quot;k_id&quot; property=&quot;kId&quot;/&gt;
        &lt;result column=&quot;k_name&quot; property=&quot;kName&quot;/&gt;
        &lt;!--这是一对一的情况--&gt;
        &lt;association property=&quot;queen&quot; javaType=&quot;com.lanou.bean.Queen&quot; resultMap=&quot;queenMap&quot;/&gt;
        &lt;!--这是一对多的情况--&gt;
        &lt;collection property=&quot;girls&quot; ofType=&quot;com.lanou.bean.Girl&quot; resultMap=&quot;girlMap&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;resultMap id=&quot;girlMap&quot; type=&quot;com.lanou.bean.Girl&quot;&gt;
        &lt;id property=&quot;gId&quot; column=&quot;g_id&quot;/&gt;
        &lt;result property=&quot;kId&quot; column=&quot;k_id&quot;/&gt;
        &lt;result property=&quot;gName&quot; column=&quot;g_name&quot;/&gt;

    &lt;/resultMap&gt;

    &lt;resultMap id=&quot;queenMap&quot; type=&quot;com.lanou.bean.Queen&quot;&gt;
        &lt;id column=&quot;q_id&quot; property=&quot;qId&quot;/&gt;
        &lt;result column=&quot;k_id&quot; property=&quot;kId&quot;/&gt;
        &lt;result column=&quot;q_name&quot; property=&quot;qName&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;insert id=&quot;insertGirl&quot;&gt;
        insert into girl (g_name,k_id) values
        &lt;foreach collection=&quot;list&quot; item=&quot;girl&quot; separator=&quot;,&quot;&gt;
            (#{girl.gName},#{girl.kId})
        &lt;/foreach&gt;
    &lt;/insert&gt;

    &lt;insert id=&quot;insertPaperGir&quot;&gt;
      insert into girl (g_name,k_id) values(#{gName},#{kId})
    &lt;/insert&gt;

    &lt;select id=&quot;findKingById&quot; resultMap=&quot;kingMap&quot;&gt;

        select
         king.k_id k_id,
         k_name,
         q_id,
         q_name,
         g_id,
         g_name
        from king
        left join girl
        on king.k_id = girl.k_id
        left join queen
        on queen.k_id = king.k_id
        where king.k_id = #{id};
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="动态sql">动态sql</h4>
<h5 id="条件分支sql">条件分支SQL</h5>
<ul>
<li>
<p>if</p>
<p>mapper中:</p>
<pre><code class="language-java">package com.lanou.mappers;
import com.lanou.bean.Student;
import java.util.List;
public interface StudentMqpper {
    List&lt;Student&gt; findStudent(Student condition);
}

</code></pre>
<p>xml中:</p>
<pre><code class="language-xml">   &lt;select id=&quot;findStudent&quot; resultType=&quot;com.lanou.bean.Student&quot;&gt;
        select * from `student`
        &lt;where&gt;
        &lt;if test=&quot;sex != null&quot; &gt;
           sex = #{sex}
        &lt;/if&gt;
        &lt;if test=&quot;name != null&quot; &gt;
            and name = #{name}
        &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<p>测试1:</p>
<pre><code class="language-java">    @Test
    public void testStudentMapper(){
        String configMybatisXmlpath = &quot;mybatis-config.xml&quot;;
        try {
            InputStream resourceAsStream = Resources.getResourceAsStream(configMybatisXmlpath);
            SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
            SqlSession sqlSession = sessionFactory.openSession();
            StudentMqpper mapper = sqlSession.getMapper(StudentMqpper.class);
            Student condition = new Student();
            condition.setName(&quot;黄忠&quot;);
            condition.setSex(&quot;男&quot;);
            List&lt;Student&gt; studentList = mapper.findStudent(condition);
            for(Student student1 :studentList ){
                System.out.println(student1.toString());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>结果:</p>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20191019174002916.png" alt="在这里插入图片描述"></figure>
<p>测试2:把setAge注释掉:</p>
<p>结果为:</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191019174018428.png" alt="在这里插入图片描述"></figure>
<ul>
<li>choose&amp;when&amp;otherwise</li>
</ul>
<h5 id="循环sql">循环SQL</h5>
<ul>
<li>forEach</li>
</ul>
<p>两种forEach:</p>
<p>第一种:</p>
<p>实例</p>
<p>mapper中:</p>
<pre><code class="language-java">public interface KingMapper {
    int insertGirl(List&lt;Girl&gt; girlList);
}

</code></pre>
<p>xml中:</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertGirl&quot;&gt;
        insert into girl (g_name,k_id) values
        &lt;foreach collection=&quot;list&quot; item=&quot;girl&quot; separator=&quot;,&quot;&gt;
            (#{girl.gName},#{girl.kId})
        &lt;/foreach&gt;
    &lt;/insert&gt;
</code></pre>
<p>第二种:</p>
<p>mapper中:</p>
<pre><code class="language-java">public interface KingMapper {
    int insertPaperGir(Girl girl);
}
</code></pre>
<p>xml中:</p>
<pre><code class="language-xml">  &lt;insert id=&quot;insertPaperGir&quot;&gt;
      insert into girl (g_name,k_id) values(#{gName},#{kId})
    &lt;/insert&gt;
</code></pre>
<h5 id="其他特殊sql">其他特殊SQL</h5>
<ul>
<li>where</li>
<li>set</li>
<li>trim</li>
</ul>
<h2 id="一级缓存">一级缓存:</h2>
<p>默认情况下是一级缓存,配置方法：</p>
<pre><code class="language-xml">&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
</code></pre>
<p>取值有两个：SESSION和STATEMENT分别对应缓存应用session会话范围和一次statement范围</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20191019174130687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>验证:</p>
<p>mapper中:</p>
<pre><code class="language-java">public interface GirlsMapper {
    List&lt;Girl&gt; queryGirls();
    int insertGirl(Girl girl);
}

</code></pre>
<p>xml中:</p>
<pre><code class="language-xml">    &lt;insert id=&quot;insertGirl&quot;&gt;
        insert into girl (g_name,k_id) value(#{gName},#{kId})
    &lt;/insert&gt;

    &lt;select id=&quot;queryGirls&quot; resultType=&quot;com.lanou.bean.Girl&quot;&gt;
        select * from girl
    &lt;/select&gt;
</code></pre>
<p>测试:注意先不要设置自动提交,这样就能看到增删改是先对缓存的改动.提交之后才能到数据库更新数据:</p>
<pre><code class="language-java">    @Test
    public void testCache(){
        String mybatisXmlpath =&quot;mybatis-config-cache.xml&quot;;
        try {
            InputStream inputStream = Resources.getResourceAsStream(mybatisXmlpath);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            SqlSession sqlSession = sqlSessionFactory.openSession();
            GirlsMapper girlsMapper = sqlSession.getMapper(GirlsMapper.class);
            List&lt;Girl&gt; girlList = girlsMapper.queryGirls();
            System.out.println(&quot;*************&quot; + girlList.size());
            for(Girl girl : girlList){
                System.out.println(girl.toString());
            }

            Girl girl = new Girl(&quot;香香&quot;,1);
            int i = girlsMapper.insertGirl(girl);
            System.out.println(i);
           // sqlSession.commit();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>结果是:</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20191019174206167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>然而数据库中则:</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/2019101917423782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>放开commit:</p>
<pre><code class="language-java">    @Test
    public void testCache(){
        String mybatisXmlpath =&quot;mybatis-config-cache.xml&quot;;
        try {
            InputStream inputStream = Resources.getResourceAsStream(mybatisXmlpath);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            SqlSession sqlSession = sqlSessionFactory.openSession();
            GirlsMapper girlsMapper = sqlSession.getMapper(GirlsMapper.class);
            List&lt;Girl&gt; girlList = girlsMapper.queryGirls();
            System.out.println(&quot;*************&quot; + girlList.size());
            for(Girl girl : girlList){
                System.out.println(girl.toString());
            }

            Girl girl = new Girl(&quot;香香&quot;,1);
            int i = girlsMapper.insertGirl(girl);
            System.out.println(i);
           // sqlSession.commit();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>结果:</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20191019174258260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20191019174326101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>结果很明显也很符合上面原理图</p>
<h2 id="二级缓存">二级缓存:</h2>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/201910191743484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MjI4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>开启二级缓存的方法</p>
<ol>
<li>第一步，打开全局二级缓存开关</li>
</ol>
<pre><code class="language-xml">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
<ol>
<li>在具体的Mapper中开启二级缓存</li>
</ol>
<pre><code class="language-xml">&lt;cache/&gt; 
</code></pre>
<p>可配置参数：</p>
<ul>
<li><code>type</code>：cache使用的类型，默认是</li>
<li><code>PerpetualCache</code>，这在一级缓存中提到过。</li>
<li><code>eviction</code>： 定义回收的策略，常见的有FIFO，LRU。</li>
<li><code>flushInterval</code>： 配置一定时间自动刷新缓存，单位是毫秒。</li>
<li><code>size</code>： 最多缓存对象的个数。</li>
<li><code>readOnly</code>： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li>
<li><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li>
</ul>
<blockquote>
<p>注意 要使用二级缓存结果集对应的POJO类必须实现序列化接口</p>
</blockquote>
<h1 id="spring与mybatis的整合">Spring与Mybatis的整合:</h1>
<h2 id="1需要的依赖">1.需要的依赖:</h2>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2在spring中管理sqlsessionfactory">2.在Spring中管理SqlSessionFactory</h2>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;

    &lt;!-- 注入数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!-- 设置mybatis核心配置文件路径（可选） --&gt;    
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/mybatis-config.xml&quot; /&gt;
     &lt;!-- 配置mybatis xml映射文件位置（如果Mapper是用注解配置的，这里就不用设置此属性了） --&gt;   
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/mappers/*&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<p>如果是注解的方式配置的Mapper，我们需要在Spring配置文件中添加mybatis的schema以支持mybatis注解扫描</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
  xsi:schemaLocation=&quot;
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
  http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt;

&lt;!-- 配置基于注解的Mapper所在包的路径 --&gt;
  &lt;mybatis:scan base-package=&quot;org.mybatis.spring.sample.mapper&quot; /&gt;


&lt;/beans&gt;
</code></pre>
<p>或者这样配置</p>
<pre><code class="language-java">@Configuration
@MapperScan(&quot;org.mybatis.spring.sample.mapper&quot;)
public class AppConfig {
  // ...
}
</code></pre>
<h2 id="3用spring管理事务">3.用Spring管理事务</h2>
<blockquote>
<p>和单独使用Spring时一样， 配置Spring的声明式事务就可以了，mybatis会自动参与到spring的事务中</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[今日打卡Jquery]]></title>
        <id>https://yihuaikun.github.io/post/jin-ri-da-qia-jquery</id>
        <link href="https://yihuaikun.github.io/post/jin-ri-da-qia-jquery">
        </link>
        <updated>2019-08-02T07:10:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jquery是什么">Jquery是什么</h1>
<p>​	 jQuery是一套跨浏览器的JavaScript库，简化HTML与JavaScript之间的操作。[1]由约翰·雷西格（John Resig）在2006年1月的BarCamp NYC上发布第一个版本。当前是由Dave Methvin领导的开发团队进行开发。全球前10,000个访问最高的网站中，有65%使用了jQuery，是当前最受欢迎的JavaScript库.</p>
<h1 id="为什么要学习jquery">为什么要学习jquery</h1>
<p>​	在使用javaScript开发的过程中,有许多的缺点</p>
<pre><code>1.查找元素的方法太少,麻烦.
2.遍历伪数组很麻烦,通常要嵌套一大推循环
3.有兼容性问题
4.想要实现动画效果也很麻烦
5.代码冗余
</code></pre>
<p>jquery有哪些优点呢:</p>
<pre><code>1.查找元素的方法多种多样
2.拥有隐式迭代性,因此不再需要手写for循环了
3.完全没有兼容性问题
4.实现动画很简单,而且功能很强大
5.代码简单,粗暴
</code></pre>
<h1 id="jquery的入口函数">jquery的入口函数</h1>
<pre><code>1. 引入jQuery文件
2. 入口函数
3. 功能实现
</code></pre>
<p>关于jquery的入口函数</p>
<pre><code class="language-javascript">//第一种写法
$(document).ready(function(){
    
});
//第二种写法
$(function() {
    
});
</code></pre>
<p>jquery入口函数和js入口函数的对比</p>
<pre><code>1.javaScript的入口函数要等页面所有资源加(包括图片,文件)加载完成菜开始执行
2.jquery的入口函数只会等待文档树加载完成就开始执行,并不会等待图片,文件的加载
</code></pre>
<h1 id="jquery对象与dom对象的区别">jquery对象与DOM对象的区别</h1>
<pre><code>1.DOM对象:使用javaScript中的方法获取页面的元素返回的就是dom对象
2.jquery对象:jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象
3.jQuery对象其实就是DOM对象的包装集(包装了DOM对象的集合(伪数组)
4.DOM对象与JQuery对象的方法不能混用
</code></pre>
<p>DOM对象转换成jQuery对象</p>
<pre><code class="language-javascript">var $obj = $(domObj);
</code></pre>
<p>jQuery对象转换成DOM对象</p>
<pre><code class="language-javascript">var $li = $(&quot;li&quot;);
//第一种方法
$li[0]
//第二种方法
$li.get[0]
</code></pre>
<h1 id="选择器">选择器</h1>
<h2 id="什么是jquery选择器">什么是jQuery选择器</h2>
<p>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。</p>
<p>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】</p>
<p>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器</p>
<h2 id="基本选择器">基本选择器</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID选择器</td>
<td>$(&quot;#id&quot;);</td>
<td>获取指定ID的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(&quot;.class'&quot;);</td>
<td>获取同一类class的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(&quot;div&quot;);</td>
<td>获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(&quot;div,p,li&quot;);</td>
<td>使用逗号分隔,只要符合条件之一就可</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(&quot;div.redClass&quot;);</td>
<td>获取class为redClass的div元素</td>
</tr>
</tbody>
</table>
<blockquote>
<p>总结:使用跟css的选择器用法一模一样</p>
</blockquote>
<h2 id="层级选择器">层级选择器</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>子代选择器</td>
<td>$(&quot;ul&gt;li&quot;);</td>
<td>使用&gt;,获取儿子层级的元素,注意,并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(&quot;ul li &quot;);</td>
<td>使用空格,代表后代选择器,获取ul下的所有元素,包括孙子等</td>
</tr>
</tbody>
</table>
<h2 id="过滤选择器">过滤选择器</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:eq(index)</td>
<td>$(&quot;li:eq(2)&quot;).css(&quot;color&quot;,&quot;red&quot;);</td>
<td>获取到li的元素中,选择索引号为2的元素,索引号index从0开始</td>
</tr>
<tr>
<td>:odd</td>
<td>$(&quot;li:odd&quot;).css(&quot;color&quot;,&quot;red&quot;);</td>
<td>获取到li元素中,选择索号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(&quot;li:even&quot;).css(&quot;color&quot;,&quot;red&quot;);</td>
<td>获取到li元素中,选择索引为偶数的元素</td>
</tr>
</tbody>
</table>
<h2 id="筛选选择器方法">筛选选择器(方法)</h2>
<blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>children(selector)</td>
<td>$(“ul”).children(“li”)</td>
<td>相当于$(“ul&gt;li”)，子类选择器</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$(“ul”).find(“li”);</td>
<td>相当于$(“ul li”),后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$(“#first”).siblings(“li”);</td>
<td>查找兄弟节点，不包括自己本身。</td>
</tr>
<tr>
<td>parent()</td>
<td>$(“#first”).parent();</td>
<td>查找父亲</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$(“li”).eq(2);</td>
<td>相当于$(“li:eq(2)”),index从0开始</td>
</tr>
<tr>
<td>next()</td>
<td>$(“li”).next()</td>
<td>找下一个兄弟</td>
</tr>
<tr>
<td>prev()</td>
<td>$(“li”).prev()</td>
<td>找上一次兄弟</td>
</tr>
</tbody>
</table>
<p>筛选选择器的功能与过滤选择器有点类似,但是用法不一样,</p>
</blockquote>
<h1 id="dom操作">DOM操作</h1>
<pre><code> DOM操作
	1. 内容操作
		1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;
		2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容
		3. val()： 获取/设置元素的value属性值
	2. 属性操作
		1. 通用属性操作
			1. attr(): 获取/设置元素的属性
			2. removeAttr():删除属性
			3. prop():获取/设置元素的属性
			4. removeProp():删除属性

			* attr和prop区别？
				1. 如果操作的是元素的固有属性，则建议使用prop
				2. 如果操作的是元素自定义的属性，则建议使用attr
		2. 对class属性操作
			1. addClass():添加class属性值
			2. removeClass():删除class属性值
			3. toggleClass():切换class属性
				* toggleClass(&quot;one&quot;): 
					* 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加
			4. css():
	3. CRUD操作:
		1. append():父元素将子元素追加到末尾
			* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾
		2. prepend():父元素将子元素追加到开头
			* 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头
		3. appendTo():
			* 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾
		4. prependTo()：
			* 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头
</code></pre>
<pre><code>	5. after():添加元素到元素后边
			* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系
		6. before():添加元素到元素前边
			* 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系
		7. insertAfter()
			* 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系
		8. insertBefore()
			* 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系

		9. remove():移除元素
			* 对象.remove():将对象删除掉
		10. empty():清空元素的所有后代元素。
			* 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点
</code></pre>
<h1 id="动画">动画</h1>
<pre><code>1. 动画
	1. 三种方式显示和隐藏元素
		1. 默认显示和隐藏方式
			1. show([speed,[easing],[fn]])
				1. 参数：
					1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)
					2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;
						* swing：动画执行时效果是 先慢，中间快，最后又慢
						* linear：动画执行时速度是匀速的
					3. fn：在动画完成时执行的函数，每个元素执行一次。

			2. hide([speed,[easing],[fn]])
			3. toggle([speed],[easing],[fn])
		
		2. 滑动显示和隐藏方式
			1. slideDown([speed],[easing],[fn])
			2. slideUp([speed,[easing],[fn]])
			3. slideToggle([speed],[easing],[fn])

		3. 淡入淡出显示和隐藏方式
			1. fadeIn([speed],[easing],[fn])
			2. fadeOut([speed],[easing],[fn])
			3. fadeToggle([speed,[easing],[fn]])
</code></pre>
<pre><code>2. 遍历
	1. js的遍历方式
		* for(初始化值;循环结束条件;步长)
	2. jq的遍历方式
		1. jq对象.each(callback)
			1. 语法：
				jquery对象.each(function(index,element){});
					* index:就是元素在集合中的索引
					* element：就是集合中的每一个元素对象

					* this：集合中的每一个元素对象
			2. 回调函数返回值：
				* true:如果当前function返回为false，则结束循环(break)。
				* false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)
		2. $.each(object, [callback])
		3. for..of: jquery 3.0 版本之后提供的方式
			for(元素对象 of 容器对象)
	
3. 事件绑定
	1. jquery标准的绑定方式
		* jq对象.事件方法(回调函数)；
		* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
			* 表单对象.submit();//让表单提交
	2. on绑定事件/off解除绑定
		* jq对象.on(&quot;事件名称&quot;,回调函数)
		* jq对象.off(&quot;事件名称&quot;)
			* 如果off方法不传递任何参数，则将组件上的所有事件全部解绑
	3. 事件切换：toggle
		* jq对象.toggle(fn1,fn2...)
			* 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....
			
		* 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。
			 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring的基本概念]]></title>
        <id>https://yihuaikun.github.io/post/spring-de-ji-ben-gai-nian</id>
        <link href="https://yihuaikun.github.io/post/spring-de-ji-ben-gai-nian">
        </link>
        <updated>2019-07-21T14:37:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springioc">SpringIOC</h1>
<h2 id="ioc容器概念">IOC容器概念</h2>
<p>IOC其实就是一个对象的容器。全称Inversion Of Control 控制反转，核心的作用就是将原来由开发人员来控制的对象管理操作交由Spring来管理。</p>
<p>SpringIOC不仅帮我们管理了对象的创建，还包括给对象增加了生命周期行为、作用域(单例、非单例)、懒加载。 配合Spring的DI， 更能方便的解决对象属性值注入、对象之间的依赖注入问题。</p>
<h2 id="ioc容器初始化方式">IOC容器初始化方式</h2>
<h3 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h3>
<p>该类负责加载类路径下的xml配置文件的方式，去初始化IOC容器上下文，具体使用步骤如下：</p>
<ol>
<li>
<p>编写配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!-- 使用bean标签将对象配置到ioc容器中 --&gt;
    &lt;bean id=&quot;man&quot; class=&quot;com.lanou3g.bean.Man&quot; /&gt;
    &lt;bean id=&quot;apple&quot; class=&quot;com.lanou3g.bean.Food&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>加载配置文件，初始化IOC容器</p>
</li>
</ol>
<pre><code class="language-java">   // 加载单个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;);
  
   // 加载多个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;});
  
   // 加载当前运行类所在的类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application或spring开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;classpath*:appliction*.xml&quot;, &quot;classpath*:spring*.xml&quot;});
</code></pre>
<blockquote>
<p>配置文件路径中可以包含通配符(*)和前缀(classpath*:，代表所有类路径，包括源码类路径和单元测试类路径)</p>
</blockquote>
<ol start="3">
<li>
<p>从容器中获取对象</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h3 id="annotationconfigapplicationcontext">AnnotationConfigApplicationContext</h3>
<p>加载通过Java注解方式配置的Bean上下文。具体使用步骤如下：</p>
<ol>
<li>
<p>定义配置类</p>
<pre><code class="language-java">@Configuration	//代表该类是一个bean的配置类，类似于xml配置中的&lt;beans&gt;标签
public class MyConfiguration {

}
</code></pre>
<ol>
<li>
<p>开启注解支持，配置扫描包路径</p>
<p>如果是通过ClassPathXmlApplicationContext初始化的上下文，则在xml中添加如下配置：</p>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;!-- 下面两个配置用于xml和注解配置混合使用时，开启注解扫描支持，并指定扫描的包路径 --&gt;
&lt;!-- 如果指定了扫描包路径，该配置可省略 --&gt;
&lt;context:annotation-config /&gt; 
&lt;context:component-scan base-package=&quot;com.lanou3g.spring&quot; /&gt;
</code></pre>
<p>如果是通过AnnotationConfigApplicationContext初始化的上下文，则需要在t通过<code>@Configuration</code>注解标注的配置类上添加 @ComponentScans注解：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;) //指定扫描包路径
public class MyConfiguration {

}
</code></pre>
</li>
<li>
<p>配置Bean</p>
<p>通过注解方式有两种方式可以将类的对象交由IOC容器中管理</p>
<ul>
<li>
<p>通过@Component的方式定义</p>
<pre><code class="language-java">@Component
public class King {
}
</code></pre>
<blockquote>
<p>适用于我们自己定义的类，或者我们可以修改源代码的类</p>
</blockquote>
</li>
<li>
<p>通过@Bean注解定义</p>
<pre><code class="language-java">public class King {
}


@Configuration
public class MyApplicationContextConf {
    @Bean
    public King king() {
        return new King();
    }
}
</code></pre>
<blockquote>
<p>适用于需要将第三方jar包中的类交由ioc管理，因为我们不能修改jar包中的代码，无法给其添加@Component注解</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>加载配置类，初始化IOC容器</p>
<pre><code class="language-java">// 加载单个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);

// 加载多个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]{MyConfiguration1.class, MyConfiguration2.class});

</code></pre>
</li>
<li>
<p>从容器中获取bean</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();

</code></pre>
</li>
</ol>
<h2 id="bean初始化方式">Bean初始化方式</h2>
<h3 id="构造方法方式最常用">构造方法方式（最常用）</h3>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDao&quot; /&gt;

</code></pre>
<h3 id="静态工厂方法">静态工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类，而不是将要创建的对象类型
	factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDaoFactory&quot; factory-method=&quot;createDao&quot; /&gt;

</code></pre>
<h3 id="实例工厂方法">实例工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是实例工厂类 
--&gt;
&lt;bean id=&quot;xxFactory&quot; class=&quot;com.test.StudentDaoFactory&quot; /&gt;
&lt;!-- 
	factory-bean：指定的是实例工厂对象
	factory-method: 指定的是工厂中的实例方法 
--&gt;
&lt;bean id=&quot;xx&quot; factory-bean=&quot;xxFactory&quot; factory-method=&quot;createDao&quot; /&gt;

</code></pre>
<h2 id="bean的命名">Bean的命名</h2>
<p>在XML中配置中可以通过<bean>标签上的id、name属性值给一个bean命名，以便在其他地方引用。</p>
<p>id属性： bean的唯一名称，只允许出现一个值。且同一个IOC容器中不允许出现两个id值一样的bean。</p>
<p>name属性： 和id类似也是给bean命名。但是name属性的值可以有多个，多个值之间使用英文逗号(,)或者英文分号(;)或者空格符隔开</p>
<h2 id="bean的作用域">Bean的作用域</h2>
<ul>
<li>
<p>prototype</p>
<p>在SpringIOC中prototype scope的意思指的是非单例，就是每次使用该bean的时候都会重新创建一个对象。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hcpmxzii-1571292053411)(https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png)]</p>
</li>
<li>
<p>singleton(默认)</p>
<p>singleton作用域是IOC中默认的作用域，代表单例。每次使用bean的时候，不会重新创建对象，在整个IOC容器中该类型的对象只有一个。</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy81LjIuMC5SRUxFQVNFL3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2ltYWdlcy9zaW5nbGV0b24ucG5n?x-oss-process=image/format,png" alt="单例作用域示意图"></figure>
</li>
</ul>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<ul>
<li>Singleton Bean的生命周期
<ul>
<li>初始化时机： 在IOC容器初始化时，就会把配置的所有单例bean实例化。</li>
<li>销毁时机：在IOC容器销毁时，所有bean的销毁方法会被调用。</li>
</ul>
</li>
<li>Prototype Bean的生命周期
<ul>
<li>初始化时机： 在实际使用该bean的时候，比如：getBean、获取依赖此bean的其他bean需要使用</li>
<li>销毁时机： 在IOC容器销毁时。（但是通过destroy-method指定的声明周期方法不会被调用，也就是说Spring不提供prototypebean完整的生命周期管理）</li>
</ul>
</li>
<li>如何指定生命周期的回调方法
<ul>
<li>xml中的init-method、destroy-method</li>
<li>注解方式@PostConstrutor、@PreDestroy</li>
</ul>
</li>
<li>指定默认的声明周期回调方法
<ul>
<li>在xml中，通过在beans标签上添加default-init-method、default-destory-method来指定</li>
<li>在注解配置中，没有对应的方法可以设置所有bean默认的生命周期回调</li>
</ul>
</li>
</ul>
<h2 id="bean懒加载">Bean懒加载</h2>
<p>lazy-init属性</p>
<p>默认是false</p>
<blockquote>
<p>懒加载配置主要是针对单例的bean，因为它默认是在容器初始化时就被实例化了。</p>
</blockquote>
<h2 id="如何优雅的停止非web-spring应用">如何优雅的停止非Web Spring应用</h2>
<p>添加一个shutdown hook。所有派生自ConfigurableApplicationContext接口的实现类都支持此方法</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);

ctx.registerShutdownHook(); //注册停止回调

</code></pre>
<h1 id="spring-di">Spring DI</h1>
<h2 id="概述">概述</h2>
<p>DI的全称是Dependency Injection（依赖注入）。IOC是将我们工程中的所有对象交由Spring来管理，DI是此基础，将对象中的属性、依赖的其他对象也管理起来，自动注入到由Spring帮我们管理的对象中。</p>
<blockquote>
<p>将要注入的对象和目标对象都必须是由SpringIOC管理的bean.</p>
</blockquote>
<h2 id="di的细节实现">DI的细节实现</h2>
<h3 id="构造参数注入">构造参数注入</h3>
<p>将一个bean创建过程中构造方法需要的参数，通过Spring DI的方式，自动注入到构造方法中。</p>
<h3 id="setter注入">Setter注入</h3>
<p>先通过一个无参的构造方法创建对象，然后通过属性的setter方法，将属性值注入到对象上。</p>
<h3 id="支持注入的类型">支持注入的类型</h3>
<ul>
<li>
<p>普通字面量</p>
<ul>
<li>String</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Byte(byte)</li>
<li>...</li>
</ul>
</li>
<li>
<p>集和类型</p>
<ul>
<li>
<p>List</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;list&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>Map</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;gameTitle&quot;&gt;
    	&lt;map&gt;
        	&lt;entry key=&quot;王者荣耀&quot; value=&quot;荣耀王者&quot; /&gt;
            &lt;entry key=&quot;王者荣耀&quot; value-ref=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;!-- set用法和List类似， 里面可以注入普通字面量值、也可以是一个bean引用，或者内部bean、或者是一个set、list、Properties  --&gt;
        &lt;set&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>java.util.Properties</p>
<pre><code class="language-xml">&lt;!-- props标签是用来注入java.util.Properties类型的属性，用法和map类似，但是属性值是在标签中间写 --&gt;
&lt;property name=&quot;gameNick&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;王者荣耀&quot;&gt;最擅长1V5&lt;/prop&gt;
        &lt;prop key=&quot;吃鸡&quot;&gt;一枪爆头&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;

</code></pre>
</li>
<li>
<p>注入空置、空字符串</p>
<pre><code class="language-xml">&lt;property name=&quot;gameNick&quot;&gt;
    &lt;null /&gt;
&lt;/property&gt;


&lt;property name=&quot;gameNick&quot; value=&quot;&quot; /&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动装配">自动装配</h3>
<h5 id="自动装配支持的策略">自动装配支持的策略</h5>
<ul>
<li>
<p>byType</p>
<p>按照类型去IOC容器中找需要的bean，如果找到一个，则自动装配；如果没找到，不注入此属性；如果找到了多个匹配类型的bean，就会报错。</p>
</li>
<li>
<p>byName</p>
<p>按照名称去IOC容器中找需要的bean，如果找到就自动注入；如果没找到，不注入此属性。</p>
</li>
<li>
<p>constructor</p>
<p>工作原理和byType类似，也是按照类型去IOC容器中找对应的bean。不同的是注入的地方不是setter，而是构造方法的参数。</p>
</li>
<li>
<p>no  （默认值）</p>
<p>如果没有打开自动注入，默认Spring不会自动装配需要的属性。</p>
</li>
</ul>
<h2 id="xml方式的di">XML方式的DI</h2>
<h3 id="构造参数注入-2">构造参数注入</h3>
<ul>
<li>
<p>常规写法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;constructor-arg name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;constructor-arg name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    ....
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>c命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; c:age=&quot;45&quot; c:x-ref=&quot;xx&quot; /&gt;

</code></pre>
</li>
</ul>
<h3 id="setter方式注入">setter方式注入</h3>
<p>setter注入能够注入的类型以及写法基本和构造参数注入时的写法一致，只不过将<construtor-arg>标签换成了<property></p>
<ul>
<li>
<p>常规用法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;property name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;property name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/property&gt;
    ....
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>p命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; p:age=&quot;45&quot; p:x-ref=&quot;xx&quot; /&gt;

</code></pre>
</li>
</ul>
<h3 id="开启自动装配">开启自动装配</h3>
<pre><code class="language-xml">&lt;!-- 
通过给当前的bean添加autowire属性开启自动注入
可选的值：参见自动装配章节
 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;&quot; autowire=&quot;&quot; /&gt;

</code></pre>
<h3 id="提高自动装配时的权重">提高自动装配时的权重</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，会优先注入primary=&quot;true&quot;的bean --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; primary=&quot;true&quot; /&gt;

</code></pre>
<h3 id="按类型自动装配时不参与候选">按类型自动装配时，不参与候选</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，autowire-candidate=&quot;false&quot;的bean会自动退出候选序列 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; autowire-candidate=&quot;false&quot; /&gt;

</code></pre>
<h2 id="注解方式的di">注解方式的DI</h2>
<ul>
<li>
<p>构造参数注入</p>
<p>在构造方法上添加 <code>@Autowired</code>注解，构造方法的参数就会自动注入进来</p>
</li>
<li>
<p>setter方法注入</p>
<p>方法有两种：</p>
<ol>
<li>在属性的setter方法上添加<code>@Autowired</code>注解</li>
<li>在属性上添加<code>@Autowired</code>注解</li>
</ol>
</li>
</ul>
<h3 id="提高自动装配时的权重-2">提高自动装配时的权重</h3>
<pre><code class="language-java">@Primary
@Component
public class Test {


}

public class Main {
    
    @Primary
    @Bean
    public void test() {
        return new Test();
    }
    
}

</code></pre>
<h2 id="注入外部property文件中的属性值">注入外部Property文件中的属性值</h2>
<h3 id="在xml中的配置方式">在XML中的配置方式</h3>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


&lt;!-- 导入外部properties文件到ioc上下文中 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;

&lt;!-- 使用占位符的方式获取properties文件中的属性值 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
&lt;/bean&gt;

</code></pre>
<h3 id="在注解中的配置方式">在注解中的配置方式</h3>
<p>通过<code>@PropertySource</code>注解可以将外部properties文件导入到上下文中，通过<code>@Value</code>注解可以获取properties文件中的属性值，并注入到当前类的属性中</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;)
@PropertySource(&quot;classpath:/jdbc.properties&quot;)
public class MyConfiguration {

	@Value(&quot;${jdbc.url}&quot;)
    private String url;
    @Value(&quot;${jdbc.user}&quot;)
    private String username;
    @Value(&quot;${jdbc.password}&quot;)
    private String password;
    @Value(&quot;${jdbc.driver}&quot;)
    private String driverClassName;
}

</code></pre>
<h1 id="springaop">SpringAOP</h1>
<h2 id="概述-2">概述</h2>
<p>AOP的全称是Aspect Oriented  Programming(面向切面编程)</p>
<p>OOP语言提供了类与类之间纵向的关系（继承、接口），而AOP补充了横向的关系（比如在不改变目标类中源代码的情况下给com.john.demo.dao包下所有类中以insert和update开头的方法添加事务管理）</p>
<h3 id="springaop和aspectj的区别">SpringAOP和AspectJ的区别</h3>
<p>AspectJ是一个专门主打面向切面编程的框架。 它是使用一种特殊的语言(扩展自Java语言)来编写切面代码，后缀是.aj格式，并且需要使用专门的编译器将其编译成jvm可以运行的class文件。</p>
<p>SpringAOP底层也是使用了AspectJ的方案，但是在上层做了很多封装层面的工作，可以让开发人员直接使用Java代码来编写切面。并且由于使用的是标准的Java语言，所以并不需要在额外安装一个专门的编译器。但是由于开发人员直接接触的是Spring AOP，那么凡是Spring中没有实现的那些AOP功能，我们就用不了了，这种情况下只能跟产品经理撕逼或者去学习原生的AspectJ。</p>
<h2 id="aop的术语">AOP的术语</h2>
<ul>
<li>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
</li>
<li>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
</li>
<li>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
</li>
<li>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
</li>
<li>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</li>
</ul>
<h2 id="在spring中使用aop">在Spring中使用AOP</h2>
<h3 id="基于xml方式使用">基于XML方式使用</h3>
<ol>
<li>
<p>把aop的schema引入</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

</code></pre>
</li>
<li>
<p>创建一个切面类，并且以bean的方式配置到IOC容器中</p>
<pre><code class="language-java">package com.lanou3g.spring;
public class MyAspect {

    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }


    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }


    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
    public void aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
    }
}

</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.lanou3g.spring.MyAspect&quot; /&gt;

</code></pre>
</li>
<li>
<p>使用<a href="aop:config">aop:config</a>标签配置aop（将切面、切入点、通知结合到一起）</p>
<ol>
<li>定义切入点表达式</li>
<li><a href="aop:aspect">aop:aspect</a>
<ol>
<li>引用外部定义的切面bean</li>
<li>配置通知，引用切入点表达式</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 切入点表示匹配com.lanou3g.spring包下的所有类中所有以oneDay开头的方法，方法的参数、返回值不限 --&gt;
	&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lanou3g.spring..*.oneDay*(..))&quot; /&gt;
    &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
    	&lt;!-- 无论是否出现异常，只要被切入的方法开始运行，都会触发此通知 --&gt;
            &lt;aop:before method=&quot;wakeup&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 无论是否出现异常，只要被切入的方法运行结束，都会触发此通知 --&gt;
            &lt;aop:after method=&quot;goToBed&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!--
            可以最大限度的对被切入方法附加功能，在方法执行前、后都可以通知（无论是否出现异常）
            ，还可以获取到被切入方法的所有信息，包括是否调用被切入的方法
            --&gt;
            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 被切入的方法正常返回值以后，会触发此通知 --&gt;
            &lt;aop:after-returning method=&quot;afterRetuing&quot; pointcut-ref=&quot;beforeOneDay&quot; returning=&quot;message&quot; /&gt;
            &lt;!-- 被切入的方法抛出异常以后，会触发此通知，并且不会触发after-returning --&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;beforeOneDay&quot; throwing=&quot;ex&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

</code></pre>
</li>
</ol>
<h3 id="基于注解方式使用">基于注解方式使用</h3>
<ol>
<li>
<p>开启AOP注解支持</p>
<p>方式一：注解的方式</p>
<pre><code class="language-xml">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}

</code></pre>
<p>方式二：xml中开启</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;

</code></pre>
<ol start="2">
<li>定义切面类</li>
</ol>
<pre><code class="language-java">/**
 * 该切面用来插入起床的逻辑
 */
@Aspect
@Component  //@Aspect注解没有将bean交给ioc容器管理的功能
public class MyAspect {

    @Before(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }

    @After(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }

    @AfterReturning(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, returning = &quot;message&quot;)
    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    @AfterThrowing(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
//    @Around(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        Object ret = null;
        try {
            ret = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
        return ret;
    }
}

</code></pre>
<blockquote>
<p>注意：@Aspect注解没有将bean交给ioc容器管理的功能，我们需要额外添加一个@Component注解</p>
</blockquote>
<ol start="3">
<li>定义切入点</li>
</ol>
<p>官方建议我们将所有的切入点统一定义到一个地方管理，在配置通知时通过引入的方式来使用。方便后期维护（一处修改，处处生效）</p>
<pre><code class="language-java">@Component
public class MyPointcut {
    // 通过@Pointcut注解定义一个切入点
    @Pointcut(&quot;execution(* oneDay(..))&quot;)
    public void allOneDayMehtod() {}
}

</code></pre>
<ol start="4">
<li>在切面类中添加要切入的代码</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
<ol start="5">
<li>在切入的代码方法上添加通知的注解</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
</li>
</ol>
<h2 id="spring-aop代理机制实现原理">Spring AOP代理机制实现原理</h2>
<p>Spring AOP底层支持两种动态实现：</p>
<ul>
<li>JDK原生的动态代理</li>
<li>Cglib动态代理</li>
</ul>
<blockquote>
<p>Spring在创建代理对象时，会自动选择要使用哪种代理方案。如果被代理的类实现了接口，那么就用JDK动态代理； 反之就使用Cglib动态代理</p>
</blockquote>
<h3 id="jdk原生动态代理">JDK原生动态代理</h3>
<p>区别静态代理每代理一个类就需要创建一个专门的代理类，动态代理只需要一个通用的代理类，即可代理所有实现了接口的类。</p>
<p>关键的API:</p>
<ul>
<li>
<p>InvocationHandler: 回调接口</p>
<pre><code class="language-java">public class MyProxy implements InvacationHandler {
    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

            String methodName = method.getName();

            // 模拟在方法运行前执行的操作
            System.out.println(methodName+ &quot; 开始执行了&quot;);

            Object retVal =  method.invoke(target, args);

            // 模拟在方法运行后执行的操作
            System.out.println(methodName+ &quot; 执行结束了，返回值： &quot; + retVal);

            return retVal;
    }
}

</code></pre>
</li>
<li>
<p>Proxy： 创建代理类的工厂类，用于动态创建代理对象</p>
<ul>
<li>
<p>如何创建代理对象</p>
<pre><code class="language-java">// 1. 创建代理对象
// 参数说明：
//		第一个参数是类加载器
//		第二个参数是被代理类实现的接口，可以写多个(写几个接口就代表你需要代理从几个接口中实现的方法)
//        第三个参数是一个实现了InvacationHandler接口的对象，用于回调
//        当我们通过代理对象去调用目标方法时，会自动执行第三个参数传进来的回调方法
		
Object obj = Proxy.newProxyInstance(classLoader, interfaces..., callback);

// 2. 将类型强转成需要代理类的接口类型
Man man = (Man)obj;

// 3. 通过代理对象去调用原本想调用的方法
man.oneDay();

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="cglib动态代理">Cglib动态代理</h3>
<p>关键的API</p>
<ul>
<li>
<p>Enhancer: 该类负责动态创建代理</p>
<ul>
<li>如何创建代理类</li>
</ul>
<pre><code class="language-java">Enhancer enhancer = new Enhancer();	//类似于一个创建代理对象的工厂类
// 下面三行类似于给工厂对象设置参数
enhancer.setSuperclass(clazz);	// 让动态创建出来的代理类继承指定的类
enhancer.setCallback(this);	 // 指定调用代理对象的方法时，进入的回调方法
return enhancer.create();	// 创建代理对象

</code></pre>
</li>
<li>
<p>MehtodInctercepor: 执行代理对象方法时的回调，作用类似于JDK动态代理中的InvacationHandler</p>
<pre><code class="language-java">public class MyCglibProxy implements MethodInterceptor {

    // 创建动态代理类的工厂对象
    private Enhancer enhancer = new Enhancer();
    public Object getProxy(Class clazz) {
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        enhancer.setUseCache(false);
        return enhancer.create();
    }

    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *  第四个参数methodProxy: 是Cglib提供的一个方法代理对象，代理了第二个参数method,它可以实现直接调用传进来对象的父类上的方法
     */ 
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        String methodName = method.getName();
        System.out.println(methodName + &quot;开始执行了&quot;);
        //代理类对象实例调用父类方法（其实就是调用被代理类上的方法实现）
        Object retVal = methodProxy.invokeSuper(proxy, args);
        System.out.println(methodName + &quot;执行结束了&quot;);
        return retVal;
    }
}

</code></pre>
</li>
</ul>
<h3 id="两种动态代理对比">两种动态代理对比</h3>
<ul>
<li>JDK动态代理要求被代理的类必须是至少实现一个接口才能代理</li>
<li>Cglib动态代理没有上述限制，也就是说他可以代理实现了接口的类，也可以代理没实现接口的类</li>
<li>JDK动态代理创建代理对象的原理是让创建的代理对象实现和被代理类一样的接口，从而代理接口中的方法</li>
<li>Cglib动态代理创建代理对象的原理是让创建的代理对象继承被代理的目标类，从而代理从父类(被代理的类)中继承过来的方法</li>
</ul>
<h3 id="强制使用cglib方式创建代理">强制使用Cglib方式创建代理</h3>
<p>如果上下文入口是XML配置文件</p>
<pre><code class="language-xml">&lt;!-- 方式一. 局部 --&gt;
&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;

&lt;!-- 方式二. 全局，在开启注解支持的地方添加属性(通过注解配置的AOP) --&gt;
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

</code></pre>
<p>如果上下文入口是注解类</p>
<pre><code class="language-java">@EnableAspectJAutoProxy(proxyTargetClass = true) // 开启AOP注解支持,并强制使用cglib代理
public class MyConfiguration {
}

</code></pre>
<h2 id="spring声明式事务">Spring声明式事务</h2>
<h3 id="在xml中使用声明式事务的步骤">在Xml中使用声明式事务的步骤</h3>
<ol>
<li>
<p>添加tx schema</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;!-- 导入外部properties文件 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;
&lt;!-- 配置数据库连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-xml">&lt;!-- 第一步： 配置事务管理器 --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;!-- 事务管理器必须依赖数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>配置事务通知，同时还能指定一些事务相关的具体属性</p>
<pre><code class="language-xml">&lt;!-- 第二步： 配置事务通知（不同于我们自己之前配置的前置、后置通知，这个是Spring帮我们封装好的，专门用来做事务管理的通知） --&gt;
&lt;!-- tx:advice封装了切面和通知相关的逻辑，不需要我们自己再去编写切面和通知的逻辑 --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- 只有触发了特定异常才回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt;
        &lt;!-- 触发以下特定异常，不会回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; no-rollback-for=&quot;NullPointerException&quot; /&gt;
        &lt;!-- 配置只读事务，只能查询，不能修改 --&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; /&gt;
        &lt;!-- 配置事务超时时间，超时后事务自动回滚，单位：秒，
                仅当传播行为propagation设置成REQUIRED或者REQUIRES_NEW的时候有效 --&gt;
        &lt;tx:method name=&quot;find*&quot; timeout=&quot;500&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

</code></pre>
</li>
<li>
<p>配置事务的AOP</p>
<p>其实就是将Spring给我们封装好的事务切面、通知和切入点整合到一起，通过AOP的方式来工作。</p>
<pre><code class="language-xml">&lt;!-- 第三步： 配置AOP --&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;allServiceMethod&quot; expression=&quot;execution(* com.lanou3g.spring.aoptx..*.*(..))&quot;/&gt;
    &lt;!-- 这个advisor类似于我们手工配置的aop:aspect，它将切面、通知和切入点做了一个整合 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;allServiceMethod&quot; /&gt;
&lt;/aop:config&gt;

</code></pre>
</li>
</ol>
<h3 id="在注解中使用声明式事务的步骤">在注解中使用声明式事务的步骤</h3>
<ol>
<li>
<p>开启注解事务支持</p>
<p>开启注解事务支持有两种方式</p>
<p>方式一： 在xml配置文件中开启</p>
<pre><code class="language-xml">&lt;!-- 开启事务注解扫描 --&gt;
&lt;!-- 如果定义的事务管理器名称就叫transactionManager，则此属性可以省略 --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;

</code></pre>
<p>方式二：在注解配置类上开启，添加<code>@EnableTransactionManagement</code>注解</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = &quot;com.lanou3g.spring&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class MyConfiguration {
    
}

</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-java">/**
* 配置数据源
* @return
*/
@Bean
public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(driver);
    dataSource.setUrl(url);
    dataSource.setUsername(user);
    dataSource.setPassword(password);
    return dataSource;
}

</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-java">/**
 * 配置事务管理器
 * @param dataSource
 * @return
 */
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}

</code></pre>
</li>
<li>
<p>在需要事务管理的方法上添加<code>@Transactional</code>注解</p>
<pre><code class="language-java">// 凡是xml中支持的事务属性，在注解中都有对应的属性来实现，具体属性含义参见xml配置
@Transactional(
    rollbackFor = Exception.class   // 指定哪些异常可以触发事务回滚
    //noRollbackFor =   // 指定事务不回滚哪些异常
    //            isolation =   // 指定事务隔离级别
    //            timeout =     // 指定事务超时时间
    //            propagation = // 指定事务传播行为
    //            readOnly = // 指定只读事务
)
public void login(User user) {

    // Service中只写业务操作代码，不需要关注事务管理
    // 1 更新用户表用户最后登录时间
    user.setLastLoginTime(new Timestamp(System.currentTimeMillis()));
    userDao.updateUser(user);

    int ret = 9 / 0;  // 模拟操作异常

    // 2 插入登录日志
    SystemLog log = new SystemLog();
    log.setAction(&quot;login&quot;);
    log.setOperator(user.getUserName());
    log.setCreateTime(new Date());
    systemLogDao.insertLog(log);
}

</code></pre>
<blockquote>
<p>@Transactional注解除了可以在方法上使用外，还可以在类上。表示类中所有的公开方法都添加此事务管理</p>
</blockquote>
</li>
</ol>
<h3 id="xml方式的事务和注解方式的事务该选哪个">XML方式的事务和注解方式的事务该选哪个？</h3>
<ul>
<li>XML方式的事务
<ul>
<li>优点是对代码没有任何侵入性，修改事务相关逻辑时，只需要修改配置文件，无需重新编译代码。另外XML方式可以通过切入点表达式灵活的对大量的类添加事务管理。</li>
<li>缺点是配置相较于注解方式麻烦一些</li>
</ul>
</li>
<li>注解方式的事务
<ul>
<li>优点是配置简单，使用方便</li>
<li>缺点是无法统一对大量的方法添加事务管理，需要在添加事务的类或方法上一个个添加事务注解，当工程中需要事务管理的代码很多时，工作量就比XML方式还要大。</li>
</ul>
</li>
</ul>
<h3 id="spring事务的传播行为和隔离级别">Spring事务的传播行为和隔离级别</h3>
<h4 id="事务的传播行为">事务的传播行为</h4>
<p>事务传播描述的事务与事务之间的传播关系， 常见的场景是在一个嵌套调用的方法中，外部方法和内部每个方法都添加了事务管理， 不同的传播行为配置，决定了最终是这些方法是使用同一个事务，还是在不同的事务中运行。</p>
<ul>
<li>
<p>​</p>
<p>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p>
</li>
<li>
<p>PROPAGATION_SUPPORTS</p>
<p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
</li>
<li>
<p>PROPAGATION_MANDATORY</p>
<p>支持当前事务，如果当前没有事务，就抛出异常。</p>
</li>
<li>
<p>PROPAGATION_REQUIRES_NEW</p>
<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NOT_SUPPORTED</p>
<p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NEVER</p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</li>
<li>
<p>PROPAGATION_NESTED</p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
</li>
</ul>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<p>事务的隔离级别描述的是多个事务之间的可见性问题。比如一个事务还未提交时，其他事务是否能看到被未提交事务修改的数据。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>这种事务隔离级别可以防止脏读、不可重复读。但是可能出现幻像读。 它保证了一个事务不能修改已经由另一个事务读取但还未提交的数据</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。</td>
</tr>
</tbody>
</table>
<h5 id="关键词">关键词：</h5>
<ul>
<li>幻读（虚读）</li>
</ul>
<blockquote>
<p>事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>
通俗的说，幻读就是指在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)</p>
</blockquote>
<ul>
<li>不可重复读取</li>
</ul>
<blockquote>
<p>事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>
在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.</p>
</blockquote>
<ul>
<li>脏读</li>
</ul>
<blockquote>
<p>事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。<br>
通俗的说，脏读就是指一个事务读取了一个未提交事务的数据</p>
</blockquote>
]]></content>
    </entry>
</feed>